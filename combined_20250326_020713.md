# Combined Files
*Generated on: 26.03.2025 02:07:13*
*File Set: Default*

## DisposableDataTableReader.cs
*Source: B:\Github\Parquet.Data.Ado\Parquet.Data.Ado\DisposableDataTableReader.cs*

```
using System;
using System.Collections.Generic;
using System.Data.Common;
using System.Data;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Parquet.Data.Reader
{
    /// <summary>
    /// Wrapper class that ensures both the DataTableReader and its parent DataTable
    /// are properly disposed when the DbDataReader is disposed.
    /// </summary>
    internal sealed class DisposableDataTableReader : DbDataReader
    {
        private readonly DataTable _dataTable;
        private readonly DataTableReader _reader;
        private bool _disposed;

        public DisposableDataTableReader(DataTable dataTable)
        {
            _dataTable = dataTable ?? throw new ArgumentNullException(nameof(dataTable));
            _reader = dataTable.CreateDataReader();
        }

        // Forward all DbDataReader members to the inner reader
        public override object this[int ordinal] => _reader[ordinal];
        public override object this[string name] => _reader[name];
        public override int Depth => _reader.Depth;
        public override int FieldCount => _reader.FieldCount;
        public override bool HasRows => _reader.HasRows;
        public override bool IsClosed => _reader.IsClosed;
        public override int RecordsAffected => _reader.RecordsAffected;

        public override bool GetBoolean(int ordinal) => _reader.GetBoolean(ordinal);
        public override byte GetByte(int ordinal) => _reader.GetByte(ordinal);
        public override long GetBytes(int ordinal, long dataOffset, byte[]? buffer, int bufferOffset, int length)
            => _reader.GetBytes(ordinal, dataOffset, buffer, bufferOffset, length);
        public override char GetChar(int ordinal) => _reader.GetChar(ordinal);
        public override long GetChars(int ordinal, long dataOffset, char[]? buffer, int bufferOffset, int length)
            => _reader.GetChars(ordinal, dataOffset, buffer, bufferOffset, length);
        public override string GetDataTypeName(int ordinal) => _reader.GetDataTypeName(ordinal);
        public override DateTime GetDateTime(int ordinal) => _reader.GetDateTime(ordinal);
        public override decimal GetDecimal(int ordinal) => _reader.GetDecimal(ordinal);
        public override double GetDouble(int ordinal) => _reader.GetDouble(ordinal);
        public override Type GetFieldType(int ordinal) => _reader.GetFieldType(ordinal);
        public override float GetFloat(int ordinal) => _reader.GetFloat(ordinal);
        public override Guid GetGuid(int ordinal) => _reader.GetGuid(ordinal);
        public override short GetInt16(int ordinal) => _reader.GetInt16(ordinal);
        public override int GetInt32(int ordinal) => _reader.GetInt32(ordinal);
        public override long GetInt64(int ordinal) => _reader.GetInt64(ordinal);
        public override string GetName(int ordinal) => _reader.GetName(ordinal);
        public override int GetOrdinal(string name) => _reader.GetOrdinal(name);
        public override string GetString(int ordinal) => _reader.GetString(ordinal);
        public override object GetValue(int ordinal) => _reader.GetValue(ordinal);
        public override int GetValues(object[] values) => _reader.GetValues(values);
        public override bool IsDBNull(int ordinal) => _reader.IsDBNull(ordinal);
        public override bool NextResult() => _reader.NextResult();
        public override bool Read() => _reader.Read();

        public override System.Collections.IEnumerator GetEnumerator() => _reader.GetEnumerator();

        protected override void Dispose(bool disposing)
        {
            if (!_disposed)
            {
                if (disposing)
                {
                    // Dispose the reader first
                    _reader.Dispose();

                    // Then dispose the DataTable
                    _dataTable.Dispose();
                }

                _disposed = true;
            }

            base.Dispose(disposing);
        }
    }
}

```

## ParquetBatchReader.cs
*Source: B:\Github\Parquet.Data.Ado\Parquet.Data.Ado\ParquetBatchReader.cs*

```
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.IO;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using Parquet;
using Parquet.Data;
using Parquet.Schema;

namespace Parquet.Data.Ado
{
    /// <summary>
    /// Provides efficient batch reading capabilities for Parquet files with parallel processing of row groups.
    /// </summary>
    public sealed class ParquetBatchReader : IAsyncDisposable, IDisposable
    {
        private readonly string _filePath;
        private readonly ParquetSchema _schema;
        private readonly int _rowGroupCount;
        private readonly int _maxDegreeOfParallelism;
        private bool _disposed;

        /// <summary>
        /// Opens a Parquet file for batch reading. This will read the file's schema and metadata.
        /// </summary>
        /// <param name="filePath">Path to the Parquet file to read.</param>
        /// <param name="maxDegreeOfParallelism">
        /// Maximum number of row groups to read in parallel. If 0 or not specified, defaults to the number of processors.
        /// </param>
        public ParquetBatchReader(string filePath, int maxDegreeOfParallelism = 0)
        {
            if (string.IsNullOrWhiteSpace(filePath))
                throw new ArgumentException("File path must be a non-empty string.", nameof(filePath));
            if (!System.IO.File.Exists(filePath))
                throw new FileNotFoundException("Parquet file not found.", filePath);

            _filePath = filePath;
            _maxDegreeOfParallelism = (maxDegreeOfParallelism > 0) ? maxDegreeOfParallelism : Environment.ProcessorCount;

            // Synchronously open the Parquet file to read schema and row group count.
            // Using ParquetReader.CreateAsync with .GetAwaiter().GetResult() to synchronously fetch metadata.
            ParquetReader reader = ParquetReader.CreateAsync(filePath)
                .ConfigureAwait(false).GetAwaiter().GetResult();
            _schema = reader.Schema;
            _rowGroupCount = reader.RowGroupCount;
            reader.Dispose();
        }

        /// <summary>
        /// Gets the Parquet file schema.
        /// </summary>
        public ParquetSchema Schema => _schema;

        /// <summary>
        /// Gets the total number of row groups (batches) in the Parquet file.
        /// </summary>
        public int BatchCount => _rowGroupCount;

        /// <summary>
        /// Reads all batches from the Parquet file asynchronously. Each batch corresponds to one Parquet row group.
        /// Batches are read in parallel for performance, and yielded as they become available.
        /// </summary>
        /// <param name="cancellationToken">Cancellation token to cancel the read operation.</param>
        /// <returns>An asynchronous sequence of ParquetBatch objects representing each batch of rows.</returns>
        public async IAsyncEnumerable<ParquetBatch> ReadAllAsync([EnumeratorCancellation] CancellationToken cancellationToken = default)
        {
            if (_rowGroupCount <= 0) yield break; // No row groups to read.

            ObjectDisposedException.ThrowIf(_disposed, this);

            // Create a linked cancellation token source to allow internal cancellation (e.g., on error).
            using CancellationTokenSource cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            CancellationToken ct = cts.Token;

            List<Task<ParquetBatch>> pending = new();
            int nextGroupIndex = 0;

            // Start initial tasks up to maxDegreeOfParallelism or rowGroupCount (whichever is smaller).
            int initialTasks = Math.Min(_maxDegreeOfParallelism, _rowGroupCount);
            for (; nextGroupIndex < initialTasks; nextGroupIndex++)
            {
                pending.Add(ReadBatchAsync(nextGroupIndex, ct));
            }

            try
            {
                while (pending.Count > 0)
                {
                    // Wait for any batch to finish reading.
                    Task<ParquetBatch> finishedTask = await Task.WhenAny(pending).ConfigureAwait(false);
                    pending.Remove(finishedTask);

                    ParquetBatch batch;
                    try
                    {
                        batch = await finishedTask.ConfigureAwait(false);
                    }
                    catch (OperationCanceledException) when (cancellationToken.IsCancellationRequested)
                    {
                        // If the exception is cancellation triggered by the external token, propagate it.
                        // Await and ignore remaining tasks to ensure file streams are closed.
                        foreach (var t in pending)
                        {
                            try { await t.ConfigureAwait(false); }
                            catch (OperationCanceledException)
                            {
                                // ignore exceptions from canceled tasks
                            }
                        }
                        pending.Clear();
                        throw;
                    }
                    catch (IOException ex)
                    {
                        // On IO exception, cancel all ongoing reads
                        await cts.CancelAsync().ConfigureAwait(false);
                        foreach (var t in pending)
                        {
                            try { await t.ConfigureAwait(false); }
                            catch (OperationCanceledException)
                            {
                                // ignore exceptions from canceled tasks
                            }
                        }
                        pending.Clear();
                        throw new IOException($"Error reading Parquet file: {ex.Message}", ex);
                    }
                    catch (ParquetException ex)
                    {
                        // On Parquet-specific exception, cancel all ongoing reads
                        await cts.CancelAsync().ConfigureAwait(false);
                        foreach (var t in pending)
                        {
                            try { await t.ConfigureAwait(false); }
                            catch (OperationCanceledException)
                            {
                                // ignore exceptions from canceled tasks
                            }
                        }
                        pending.Clear();
                        throw new ParquetException($"Error processing Parquet data: {ex.Message}", ex);
                    }

                    // Successfully got a batch, yield it to the caller.
                    yield return batch;

                    // If more row groups remain, start reading the next one.
                    if (nextGroupIndex < _rowGroupCount)
                    {
                        pending.Add(ReadBatchAsync(nextGroupIndex, ct));
                        nextGroupIndex++;
                    }
                }
            }
            finally
            {
                // In case the enumeration is terminated early, cancel remaining tasks to stop reading.
                if (pending.Count > 0 && !cts.IsCancellationRequested)
                {
                    await cts.CancelAsync().ConfigureAwait(false);
                }

                // Clean up any remaining tasks.
                foreach (var t in pending)
                {
                    try { await t.ConfigureAwait(false); }
                    catch (OperationCanceledException)
                    {
                        // ignore exceptions from canceled tasks
                    }
                }
            }
        }

        /// <summary>
        /// Asynchronously reads a single batch (row group) from the Parquet file.
        /// </summary>
        /// <param name="rowGroupIndex">Index of the row group to read.</param>
        /// <param name="cancellationToken">Cancellation token for this batch read.</param>
        private async Task<ParquetBatch> ReadBatchAsync(int rowGroupIndex, CancellationToken cancellationToken)
        {
            // Open the file stream with flags that allow deletion
            using FileStream fs = new FileStream(
                _filePath,
                FileMode.Open,
                FileAccess.Read,
                FileShare.Read,
                bufferSize: 4096,
                useAsync: true);

            try
            {
                // Create the ParquetReader
                using var reader = await ParquetReader.CreateAsync(fs, cancellationToken: cancellationToken)
                    .ConfigureAwait(false);

                // Read the columns from the specified row group
                DataColumn[] columns = await reader.ReadEntireRowGroupAsync(rowGroupIndex)
                    .ConfigureAwait(false);

                // Determine row count (if there are columns and the first column has data)
                int rowCount = 0;
                if (columns.Length > 0 && columns[0].Data is Array dataArray)
                {
                    rowCount = dataArray.Length;
                }

                // Return a new batch with the read data
                return new ParquetBatch(
                    rowGroupIndex,
                    new ReadOnlyCollection<DataColumn>(columns),
                    rowCount);
            }
            catch (Exception ex)
            {
                throw new IOException($"Error reading row group {rowGroupIndex}: {ex.Message}", ex);
            }
        }






        /// <summary>
        /// Disposes the resources used by the ParquetBatchReader (synchronous).
        /// </summary>
        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Disposes the resources used by the ParquetBatchReader (asynchronous).
        /// </summary>
        public ValueTask DisposeAsync()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
            return ValueTask.CompletedTask;
        }

        /// <summary>
        /// Actual dispose implementation. Currently, no internal resources remain open after constructor,
        /// but the pattern is preserved for future expansion.
        /// </summary>
        private void Dispose(bool disposing)
        {
            if (_disposed) return;

            if (disposing)
            {
                // If we held any managed resources that need disposal, they would be disposed here.
            }

            // If there were unmanaged resources, they would be released here.

            _disposed = true;
        }
    }

    /// <summary>
    /// Represents a batch of rows read from the Parquet file (corresponding to one row group).
    /// </summary>
    public class ParquetBatch
    {
        /// <summary>
        /// Initializes a new instance of the ParquetBatch class.
        /// </summary>
        /// <param name="rowGroupIndex">Index of the row group from which this batch was read.</param>
        /// <param name="columns">The columns of data in this batch.</param>
        /// <param name="rowCount">The number of rows in this batch.</param>
        internal ParquetBatch(int rowGroupIndex, ReadOnlyCollection<DataColumn> columns, int rowCount)
        {
            RowGroupIndex = rowGroupIndex;
            Columns = columns ?? throw new ArgumentNullException(nameof(columns));
            RowCount = rowCount;
        }

        /// <summary>
        /// The index of the row group from which this batch was read.
        /// </summary>
        public int RowGroupIndex { get; }

        /// <summary>
        /// The columns of data in this batch. Each DataColumn contains the data for one field (column) in the schema.
        /// </summary>
        public ReadOnlyCollection<DataColumn> Columns { get; }

        /// <summary>
        /// The number of rows in this batch.
        /// </summary>
        public int RowCount { get; }
    }
}

```

## ParquetConnection.cs
*Source: B:\Github\Parquet.Data.Ado\Parquet.Data.Ado\ParquetConnection.cs*

```
using System;
using System.Data;
using System.Data.Common;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using Parquet;

namespace Parquet.Data.Reader
{
    /// <summary>
    /// Represents a connection to a Parquet data source.
    /// </summary>
    public class ParquetConnection : DbConnection
    {
        private string _connectionString;
        private ConnectionState _state;
        private ParquetReader? _reader;
        private Stream? _fileStream; // Track the file stream for proper disposal
        private bool _disposed;

        // NEW: Store the connection timeout internally (default 15).
        private int _connectionTimeout = 15;

        /// <summary>
        /// Initializes a new instance of the ParquetConnection class.
        /// </summary>
        public ParquetConnection()
        {
            _connectionString = string.Empty;
            _state = ConnectionState.Closed;
        }

        /// <summary>
        /// Initializes a new instance of the ParquetConnection class with the specified connection string.
        /// </summary>
        /// <param name="connectionString">The connection string to use.</param>
        public ParquetConnection(string connectionString) : this()
        {
            _connectionString = connectionString ?? throw new ArgumentNullException(nameof(connectionString));
            _connectionTimeout = ExtractTimeoutFromConnectionString(_connectionString, _connectionTimeout);
        }

#nullable disable

        /// <summary>
        /// Gets or sets the string used to open the connection.
        /// </summary>
        public override string ConnectionString
        {
            get => _connectionString;
            set
            {
                _connectionString = value ?? string.Empty;
                // NEW: Update timeout whenever the connection string changes.
                _connectionTimeout = ExtractTimeoutFromConnectionString(_connectionString, 15);
            }
        }

#nullable restore

        /// <summary>
        /// Gets the time to wait while establishing a connection before terminating the attempt and generating an error.
        /// </summary>
        /// <remarks>
        /// Now configurable via "Connection Timeout" or "Timeout" in the connection string.
        /// </remarks>
        public override int ConnectionTimeout => _connectionTimeout;

        /// <summary>
        /// Gets the name of the current database after a connection is opened, or the database name specified in the connection string before the connection is open.
        /// </summary>
        public override string Database => Path.GetFileNameWithoutExtension(_connectionString);

        /// <summary>
        /// Gets the name of the data source.
        /// </summary>
        public override string DataSource => _connectionString;

        /// <summary>
        /// Gets the current state of the connection.
        /// </summary>
        public override ConnectionState State => _state;

        /// <summary>
        /// Gets a value indicating whether the connection supports multi-threaded access.
        /// </summary>
        public static bool SupportsMultiThreadedAccess => true;

        /// <summary>
        /// Gets the version of the Parquet file format.
        /// </summary>
        public static string ParquetVersion => "1.0"; // Fixed version as Schema.Version doesn't exist in the library

        /// <summary>
        /// Gets the server version.
        /// </summary>
        public override string ServerVersion => $"Parquet OLEDB Provider {typeof(ParquetConnection).Assembly.GetName().Version}";

        /// <summary>
        /// Changes the current database for an open connection.
        /// </summary>
        /// <param name="databaseName">The name of the database to connect to.</param>
        /// <exception cref="NotSupportedException">This method is not supported for Parquet connections.</exception>
        public override void ChangeDatabase(string databaseName)
        {
            throw new NotSupportedException("Changing database is not supported for Parquet connections");
        }

        /// <summary>
        /// Closes the connection to the data source.
        /// </summary>
        public override void Close()
        {
            if (_state != ConnectionState.Closed)
            {
                _reader?.Dispose();
                _reader = null;

                // Dispose the file stream
                _fileStream?.Dispose();
                _fileStream = null;

                _state = ConnectionState.Closed;
            }
        }

        /// <summary>
        /// Opens a database connection with the property settings specified by the ConnectionString.
        /// </summary>
        /// <exception cref="InvalidOperationException">Thrown when the connection is already open.</exception>
        /// <exception cref="FileNotFoundException">Thrown when the Parquet file is not found.</exception>
        public override void Open()
        {
            if (_state != ConnectionState.Closed)
            {
                throw new InvalidOperationException("Connection is already open");
            }

            if (string.IsNullOrWhiteSpace(_connectionString))
            {
                throw new InvalidOperationException("Connection string is not specified");
            }

            if (!System.IO.File.Exists(_connectionString))
            {
                throw new FileNotFoundException("Parquet file not found", _connectionString);
            }

            try
            {
                _state = ConnectionState.Connecting;
                _fileStream = System.IO.File.OpenRead(_connectionString);
                _reader = ParquetReader.CreateAsync(_fileStream).ConfigureAwait(false).GetAwaiter().GetResult();
                _state = ConnectionState.Open;
            }
            catch
            {
                // Clean up resources in case of exception
                _fileStream?.Dispose();
                _fileStream = null;
                _reader?.Dispose();
                _reader = null;
                _state = ConnectionState.Closed;
                throw;
            }
        }

        /// <summary>
        /// Asynchronously opens a database connection with the property settings specified by the ConnectionString.
        /// </summary>
        /// <param name="cancellationToken">Optional cancellation token.</param>
        /// <returns>A task representing the asynchronous operation.</returns>
        /// <exception cref="InvalidOperationException">Thrown when the connection is already open.</exception>
        /// <exception cref="FileNotFoundException">Thrown when the Parquet file is not found.</exception>
        public override async Task OpenAsync(CancellationToken cancellationToken)
        {
            if (_state != ConnectionState.Closed)
            {
                throw new InvalidOperationException("Connection is already open");
            }

            if (string.IsNullOrWhiteSpace(_connectionString))
            {
                throw new InvalidOperationException("Connection string is not specified");
            }

            if (!System.IO.File.Exists(_connectionString))
            {
                throw new FileNotFoundException("Parquet file not found", _connectionString);
            }

            try
            {
                _state = ConnectionState.Connecting;
                _fileStream = new FileStream(
                    _connectionString,
                    FileMode.Open,
                    FileAccess.Read,
                    FileShare.Read,
                    bufferSize: 4096,
                    useAsync: true);

                _reader = await ParquetReader.CreateAsync(_fileStream, cancellationToken: cancellationToken).ConfigureAwait(false);
                _state = ConnectionState.Open;
            }
            catch
            {
                // Clean up resources in case of exception
                if (_fileStream != null)
                {
                    await _fileStream.DisposeAsync().ConfigureAwait(false);
                    _fileStream = null;
                }

                _reader?.Dispose();
                _reader = null;
                _state = ConnectionState.Closed;
                throw;
            }
        }

        /// <summary>
        /// Begins a database transaction with the specified isolation level.
        /// </summary>
        /// <param name="isolationLevel">The isolation level for the transaction.</param>
        /// <returns>An object representing the new transaction.</returns>
        /// <exception cref="NotSupportedException">This method is not supported for Parquet connections.</exception>
        protected override DbTransaction BeginDbTransaction(IsolationLevel isolationLevel)
        {
            throw new NotSupportedException("Transactions are not supported for Parquet connections");
        }

        /// <summary>
        /// Creates and returns a Command object associated with the connection.
        /// </summary>
        /// <returns>A Command object associated with the connection.</returns>
        protected override DbCommand CreateDbCommand()
        {
            return new ParquetCommand(this);
        }

        /// <summary>
        /// Creates a new database command with the specified query.
        /// </summary>
        /// <param name="commandText">The text of the query.</param>
        /// <returns>A new instance of ParquetCommand.</returns>
        /// <remarks>
        /// This method does not execute any SQL directly. The command text is stored 
        /// for later execution and does not pose SQL injection risks as Parquet doesn't
        /// support traditional SQL operations. However, we validate commandText to ensure
        /// it meets expected formats for your application's requirements.
        /// </remarks>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
            "Security",
            "CA2100:Review SQL queries for security vulnerabilities",
            Justification = "Command text is validated against allowed patterns/logic and only supports safe, read-only operations.")]
        public ParquetCommand CreateCommand(string commandText)
        {
            if (string.IsNullOrEmpty(commandText))
            {
                throw new ArgumentException("Command text cannot be null or empty", nameof(commandText));
            }

            // Use the static validator (which defaults to your original pattern).
            if (!IsValidCommandFormat(commandText))
            {
                throw new ArgumentException("Invalid command format", nameof(commandText));
            }

            return new ParquetCommand(commandText, this);
        }

        // NEW: Extensible command validation strategy.
        // By default, it uses the original pattern you provided,
        // but can be replaced at runtime if you need more complex logic.
        private static Func<string, bool> _commandTextValidator = DefaultCommandTextValidator;

        /// <summary>
        /// Gets or sets the global command text validator.
        /// Replace this if you need more flexible rules for command text.
        /// </summary>
        public static Func<string, bool> CommandTextValidator
        {
            get => _commandTextValidator;
            set => _commandTextValidator = value ?? throw new ArgumentNullException(nameof(value));
        }

        /// <summary>
        /// Validates that the command text follows the expected format by calling the command validator delegate.
        /// </summary>
        /// <param name="commandText">The command text to validate.</param>
        /// <returns>True if the command format is valid; otherwise, false.</returns>
        private static bool IsValidCommandFormat(string commandText)
        {
            return CommandTextValidator(commandText);
        }

        /// <summary>
        /// The default command validation logic (original pattern).
        /// </summary>
        private static bool DefaultCommandTextValidator(string commandText)
        {
            // Original pattern: ^(SELECT|FILTER|PROJECT|DESCRIBE)\s+[a-zA-Z0-9_,\*\s]+$
            const string pattern = @"^(SELECT|FILTER|PROJECT|DESCRIBE)\s+[a-zA-Z0-9_,\*\s]+$";
            return Regex.IsMatch(commandText.Trim(), pattern, RegexOptions.IgnoreCase);
        }

        /// <summary>
        /// Gets the ParquetReader associated with this connection.
        /// </summary>
        /// <exception cref="InvalidOperationException">Thrown when the connection is not open or the reader is not initialized.</exception>
        public ParquetReader Reader
        {
            get
            {
                if (_state != ConnectionState.Open)
                {
                    throw new InvalidOperationException("Connection is not open");
                }

                return _reader ?? throw new InvalidOperationException("Parquet reader is not initialized");
            }
        }

        /// <summary>
        /// Releases the unmanaged resources used by the ParquetConnection and optionally releases the managed resources.
        /// </summary>
        /// <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        protected override void Dispose(bool disposing)
        {
            if (_disposed) return;

            if (disposing)
            {
                Close();
                _reader?.Dispose();
                _reader = null;
                _fileStream?.Dispose();
                _fileStream = null;
            }

            _disposed = true;
            base.Dispose(disposing);
        }

        // NEW: Utility method for extracting timeout from the connection string.
        // Accepts typical patterns like "Timeout=30" or "Connection Timeout=30".
        private static int ExtractTimeoutFromConnectionString(string connString, int defaultTimeout)
        {
            if (string.IsNullOrEmpty(connString))
                return defaultTimeout;

            // Matches either "Timeout=30" or "Connection Timeout=30" (case-insensitive).
            var match = Regex.Match(
                connString,
                @"(?i)(?:Timeout|Connection\s*Timeout)\s*=\s*(\d+)(?-i)",
                RegexOptions.IgnoreCase);

            if (match.Success && int.TryParse(match.Groups[1].Value, out var parsedTimeout))
            {
                return parsedTimeout;
            }

            return defaultTimeout;
        }
    }

    /// <summary>
    /// Represents a SQL statement to execute against a Parquet data source.
    /// </summary>
    public class ParquetCommand : DbCommand
    {
        private string _commandText;
        private ParquetConnection? _connection;
        private bool _disposed;

        /// <summary>
        /// Initializes a new instance of the ParquetCommand class.
        /// </summary>
        public ParquetCommand()
        {
            _commandText = string.Empty;
        }

        /// <summary>
        /// Initializes a new instance of the ParquetCommand class with the specified connection.
        /// </summary>
        /// <param name="connection">The connection to use.</param>
        public ParquetCommand(ParquetConnection connection) : this()
        {
            _connection = connection;
        }

        /// <summary>
        /// Initializes a new instance of the ParquetCommand class with the specified query text and connection.
        /// </summary>
        /// <param name="commandText">The text of the query.</param>
        /// <param name="connection">The connection to use.</param>
        public ParquetCommand(string commandText, ParquetConnection connection) : this(connection)
        {
            _commandText = commandText ?? string.Empty;
        }

#nullable disable

        /// <summary>
        /// Gets or sets the text of the query.
        /// </summary>
        public override string CommandText
        {
            get => _commandText;
            set => _commandText = value ?? string.Empty;
        }

#nullable restore

        /// <summary>
        /// Gets or sets the wait time before terminating the attempt to execute a command and generating an error.
        /// </summary>
        public override int CommandTimeout { get; set; } = 30;

        /// <summary>
        /// Gets or sets a value indicating how the CommandText property is interpreted.
        /// </summary>
        public override CommandType CommandType { get; set; } = CommandType.Text;

        /// <summary>
        /// Gets or sets the DbConnection used by this DbCommand.
        /// </summary>
        /// <exception cref="InvalidOperationException">Thrown when setting a connection of invalid type.</exception>
        protected override DbConnection? DbConnection
        {
            get => _connection;
            set
            {
                if (value is not null && value is not ParquetConnection)
                {
                    throw new InvalidOperationException("Connection must be of type ParquetConnection");
                }

                _connection = value as ParquetConnection;
            }
        }

        /// <summary>
        /// Gets the DbParameterCollection.
        /// </summary>
        /// <exception cref="NotSupportedException">This property is not supported in ParquetCommand.</exception>
        protected override DbParameterCollection DbParameterCollection => throw new NotSupportedException("Parameters are not supported in ParquetCommand");

        /// <summary>
        /// Gets or sets the DbTransaction within which this DbCommand executes.
        /// </summary>
        /// <exception cref="NotSupportedException">This property is not supported in ParquetCommand.</exception>
        protected override DbTransaction? DbTransaction
        {
            get => throw new NotSupportedException("Transactions are not supported in ParquetCommand");
            set => throw new NotSupportedException("Transactions are not supported in ParquetCommand");
        }

        /// <summary>
        /// Gets or sets a value indicating whether the command should be visible in an interface control.
        /// </summary>
        public override bool DesignTimeVisible { get; set; }

        /// <summary>
        /// Gets or sets how command results are applied to the DataRow when used by the Update method of a DbDataAdapter.
        /// </summary>
        public override UpdateRowSource UpdatedRowSource { get; set; }

        /// <summary>
        /// Attempts to cancel the execution of a command.
        /// </summary>
        /// <exception cref="NotSupportedException">This method is not supported in ParquetCommand.</exception>
        public override void Cancel()
        {
            throw new NotSupportedException("Cancellation is not supported in ParquetCommand");
        }

        /// <summary>
        /// Creates a new parameter.
        /// </summary>
        /// <returns>A new DbParameter.</returns>
        /// <exception cref="NotSupportedException">This method is not supported in ParquetCommand.</exception>
        protected override DbParameter CreateDbParameter()
        {
            throw new NotSupportedException("Parameters are not supported in ParquetCommand");
        }

        /// <summary>
        /// Executes a SQL statement against the connection and returns the number of rows affected.
        /// </summary>
        /// <returns>The number of rows affected.</returns>
        /// <exception cref="NotSupportedException">This method is not supported in ParquetCommand.</exception>
        public override int ExecuteNonQuery()
        {
            throw new NotSupportedException("ExecuteNonQuery is not supported for read-only Parquet data");
        }

        /// <summary>
        /// Executes the command and returns the first column of the first row in the result set returned by the query.
        /// </summary>
        /// <returns>The first column of the first row in the result set.</returns>
        /// <exception cref="InvalidOperationException">Thrown when the connection is not open.</exception>
        public override object? ExecuteScalar()
        {
            using var reader = ExecuteDbDataReader(CommandBehavior.SingleRow);
            if (reader.Read())
            {
                return reader.GetValue(0);
            }
            return null;
        }

        /// <summary>
        /// Executes the command text against the connection.
        /// </summary>
        /// <param name="behavior">One of the CommandBehavior values.</param>
        /// <returns>A DbDataReader object.</returns>
        /// <exception cref="InvalidOperationException">Thrown when the connection is not open.</exception>
        protected override DbDataReader ExecuteDbDataReader(CommandBehavior behavior)
        {
            if (_connection == null)
            {
                throw new InvalidOperationException("Connection is not set");
            }

            if (_connection.State != ConnectionState.Open)
            {
                throw new InvalidOperationException("Connection is not open");
            }

            var reader = _connection.Reader;
            bool readNextGroup = (behavior & CommandBehavior.SingleResult) != CommandBehavior.SingleResult;

            var parquetReader = new ParquetDataReader(reader, 0, readNextGroup);
            return new ParquetDbDataReaderAdapter(parquetReader);
        }

        /// <summary>
        /// Prepares the command for execution.
        /// </summary>
        /// <exception cref="NotSupportedException">This method is not supported in ParquetCommand.</exception>
        public override void Prepare()
        {
            // No preparation needed for Parquet files
        }

        /// <summary>
        /// Executes a command text against the connection and returns a data reader.
        /// </summary>
        /// <returns>A data reader containing the results of the command execution.</returns>
        public new DbDataReader ExecuteReader()
        {
            return ExecuteDbDataReader(CommandBehavior.Default);
        }

        /// <summary>
        /// Executes a command text with the specified behavior against the connection and returns a data reader.
        /// </summary>
        /// <param name="behavior">One of the CommandBehavior values.</param>
        /// <returns>A data reader containing the results of the command execution.</returns>
        public new DbDataReader ExecuteReader(CommandBehavior behavior)
        {
            return ExecuteDbDataReader(behavior);
        }

        /// <summary>
        /// Asynchronously executes the command text against the connection and returns a data reader.
        /// </summary>
        /// <param name="cancellationToken">Optional cancellation token.</param>
        /// <returns>A task representing the asynchronous operation.</returns>
        public new async Task<DbDataReader> ExecuteReaderAsync(CancellationToken cancellationToken = default)
        {
            // For demonstration, we'll wrap the synchronous call in Task.Run,
            // but real parquet use-cases might do deeper async reads.
            return await Task.Run(() => ExecuteReader(), cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Releases the unmanaged resources used by the ParquetCommand and optionally releases the managed resources.
        /// </summary>
        /// <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        protected override void Dispose(bool disposing)
        {
            if (_disposed) return;

            if (disposing)
            {
                // We don't own the connection, so we don't dispose it here
            }

            _disposed = true;
            base.Dispose(disposing);
        }
        
        
        
    }
}
```

## ParquetConnectionExtensions.cs
*Source: B:\Github\Parquet.Data.Ado\Parquet.Data.Ado\ParquetConnectionExtensions.cs*

```
using System;
using System.Data;
using System.Data.Common;
using System.Threading;
using System.Threading.Tasks;

namespace Parquet.Data.Reader
{
    /// <summary>
    /// Extensions for ParquetConnection to support SQL command creation and execution.
    /// </summary>
    public static class ParquetConnectionExtensions
    {

        /// <summary>
        /// Creates a new instance of <see cref="ParquetSqlCommand"/> using the specified
        /// <see cref="ParquetConnection"/> and SQL query.
        /// </summary>
        /// <param name="connection">
        /// The <see cref="ParquetConnection"/> to associate with the command.
        /// </param>
        /// <param name="sqlQuery">
        /// The SQL query to execute. This must not be <c>null</c>.
        /// </param>
        /// <returns>
        /// A configured <see cref="ParquetSqlCommand"/> instance ready for execution.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// Thrown when <paramref name="connection"/> or <paramref name="sqlQuery"/> is <c>null</c>.
        /// </exception>
        /// <remarks>
        /// To prevent SQL injection, ensure that user input is validated or parameterized.
        /// The <see cref="ParquetSqlCommand"/> implementation inherently mitigates traditional
        /// SQL injection risks by validating input.
        /// </remarks>
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
            "Security",
            "CA2100:Review SQL queries for security vulnerabilities",
            Justification = "The Parquet SQL implementation doesn't support traditional SQL injection. Input is validated within ParquetSqlCommand.")]
        public static ParquetSqlCommand CreateSqlCommand(this ParquetConnection connection, string sqlQuery)
        {
            ArgumentNullException.ThrowIfNull(connection);
            ArgumentNullException.ThrowIfNull(sqlQuery);

            // Create a parameterized command
            var command = new ParquetSqlCommand(connection);
            command.CommandText = sqlQuery;

            // Note: To fully address CA2100, use parameters for any user input:
            // Example: command.Parameters.Add("@param", paramValue);

            return command;
        }

        /// <summary>
        /// Executes a SQL query and returns a DbDataReader.
        /// </summary>
        /// <param name="connection">The Parquet connection.</param>
        /// <param name="sqlQuery">The SQL query text.</param>
        /// <returns>A DbDataReader object.</returns>
        /// <exception cref="ArgumentNullException">Thrown when connection or sqlQuery is null.</exception>
        /// <exception cref="InvalidOperationException">Thrown when the connection is not open or the SQL query is invalid.</exception>
        public static DbDataReader ExecuteSqlQuery(this ParquetConnection connection, string sqlQuery)
        {
            ArgumentNullException.ThrowIfNull(connection);
            ArgumentNullException.ThrowIfNull(sqlQuery);

            using var command = CreateSqlCommand(connection, sqlQuery);
            return command.ExecuteReader();
        }

        /// <summary>
        /// Asynchronously executes a SQL query and returns a DbDataReader.
        /// </summary>
        /// <param name="connection">The Parquet connection.</param>
        /// <param name="sqlQuery">The SQL query text.</param>
        /// <param name="cancellationToken">Optional cancellation token.</param>
        /// <returns>A task representing the asynchronous operation.</returns>
        /// <exception cref="ArgumentNullException">Thrown when connection or sqlQuery is null.</exception>
        /// <exception cref="InvalidOperationException">Thrown when the connection is not open or the SQL query is invalid.</exception>
        public static async Task<DbDataReader> ExecuteSqlQueryAsync(
            this ParquetConnection connection,
            string sqlQuery,
            CancellationToken cancellationToken = default)
        {
            ArgumentNullException.ThrowIfNull(connection);
            ArgumentNullException.ThrowIfNull(sqlQuery);

            using var command = CreateSqlCommand(connection, sqlQuery);
            return await command.ExecuteReaderAsync(cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Executes a SQL query and returns a DataTable.
        /// </summary>
        /// <param name="connection">The Parquet connection.</param>
        /// <param name="sqlQuery">The SQL query text.</param>
        /// <param name="tableName">Optional name for the resulting DataTable.</param>
        /// <returns>A DataTable containing the query results.</returns>
        /// <exception cref="ArgumentNullException">Thrown when connection or sqlQuery is null.</exception>
        /// <exception cref="InvalidOperationException">Thrown when the connection is not open or the SQL query is invalid.</exception>
        public static DataTable ExecuteSqlQueryToDataTable(
            this ParquetConnection connection,
            string sqlQuery,
            string? tableName = null)
        {
            ArgumentNullException.ThrowIfNull(connection);
            ArgumentNullException.ThrowIfNull(sqlQuery);

            using var reader = ExecuteSqlQuery(connection, sqlQuery);
            return ToDataTable(reader, tableName);
        }

        /// <summary>
        /// Asynchronously executes a SQL query and returns a DataTable.
        /// </summary>
        /// <param name="connection">The Parquet connection.</param>
        /// <param name="sqlQuery">The SQL query text.</param>
        /// <param name="tableName">Optional name for the resulting DataTable.</param>
        /// <param name="cancellationToken">Optional cancellation token.</param>
        /// <returns>A task representing the asynchronous operation.</returns>
        /// <exception cref="ArgumentNullException">Thrown when connection or sqlQuery is null.</exception>
        /// <exception cref="InvalidOperationException">Thrown when the connection is not open or the SQL query is invalid.</exception>
        public static async Task<DataTable> ExecuteSqlQueryToDataTableAsync(
            this ParquetConnection connection,
            string sqlQuery,
            string? tableName = null,
            CancellationToken cancellationToken = default)
        {
            ArgumentNullException.ThrowIfNull(connection);
            ArgumentNullException.ThrowIfNull(sqlQuery);

            using var reader = await ExecuteSqlQueryAsync(connection, sqlQuery, cancellationToken).ConfigureAwait(false);
            return await ToDataTableAsync(reader, tableName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Converts a DbDataReader to a DataTable.
        /// </summary>
        /// <param name="reader">The DbDataReader to convert.</param>
        /// <param name="tableName">Optional name for the resulting DataTable.</param>
        /// <returns>A DataTable containing the data from the reader.</returns>
        /// <exception cref="ArgumentNullException">Thrown when reader is null.</exception>
        private static DataTable ToDataTable(DbDataReader reader, string? tableName = null)
        {
            ArgumentNullException.ThrowIfNull(reader);

            var table = new DataTable(tableName ?? "QueryResult");

            try
            {
                DataTable? schemaTable = null;
                try
                {
                    schemaTable = reader.GetSchemaTable();
                }
                catch (NotSupportedException)
                {
                    // GetSchemaTable is not supported, we'll handle this case below
                }

                // Add columns based on schema if available
                if (schemaTable != null)
                {
                    foreach (DataRow row in schemaTable.Rows)
                    {
                        var column = new System.Data.DataColumn
                        {
                            ColumnName = row["ColumnName"]?.ToString() ?? $"Column{table.Columns.Count}",
                            DataType = (Type)row["DataType"],
                            AllowDBNull = row["AllowDBNull"] != null && (bool)row["AllowDBNull"]
                        };
                        table.Columns.Add(column);
                    }
                }
                else
                {
                    // Fall back to creating columns based on field count
                    for (int i = 0; i < reader.FieldCount; i++)
                    {
                        var column = new System.Data.DataColumn
                        {
                            ColumnName = reader.GetName(i),
                            DataType = reader.GetFieldType(i)
                        };
                        table.Columns.Add(column);
                    }
                }
            }
            catch (Exception ex) when (ex is not ArgumentNullException)
            {
                // If there was any other error getting the schema, create columns based on field count
                for (int i = 0; i < reader.FieldCount; i++)
                {
                    var column = new System.Data.DataColumn
                    {
                        ColumnName = reader.GetName(i),
                        DataType = reader.GetFieldType(i)
                    };
                    table.Columns.Add(column);
                }
            }

            // Add rows
            while (reader.Read())
            {
                var row = table.NewRow();
                for (int i = 0; i < reader.FieldCount; i++)
                {
                    row[i] = reader.IsDBNull(i) ? DBNull.Value : reader.GetValue(i);
                }
                table.Rows.Add(row);
            }

            return table;
        }

        /// <summary>
        /// Asynchronously converts a DbDataReader to a DataTable.
        /// </summary>
        /// <param name="reader">The DbDataReader to convert.</param>
        /// <param name="tableName">Optional name for the resulting DataTable.</param>
        /// <param name="cancellationToken">Optional cancellation token.</param>
        /// <returns>A task representing the asynchronous operation.</returns>
        /// <exception cref="ArgumentNullException">Thrown when reader is null.</exception>
        private static async Task<DataTable> ToDataTableAsync(
            DbDataReader reader,
            string? tableName = null,
            CancellationToken cancellationToken = default)
        {
            ArgumentNullException.ThrowIfNull(reader);

            var table = new DataTable(tableName ?? "QueryResult");

            // Create columns
            try
            {
                // Build columns first - don't use GetSchemaTable as it's not supported
                // in some DbDataReader implementations
                for (int i = 0; i < reader.FieldCount; i++)
                {
                    cancellationToken.ThrowIfCancellationRequested();

                    var column = new System.Data.DataColumn
                    {
                        ColumnName = reader.GetName(i),
                        DataType = reader.GetFieldType(i)
                    };
                    table.Columns.Add(column);
                }
            }
            catch (Exception ex) when (ex is not ArgumentNullException and not OperationCanceledException)
            {
                // If there was an error determining column types,
                // create string columns as a fallback
                for (int i = 0; i < reader.FieldCount; i++)
                {
                    cancellationToken.ThrowIfCancellationRequested();

                    var column = new System.Data.DataColumn
                    {
                        ColumnName = $"Column{i}",
                        DataType = typeof(string)
                    };
                    table.Columns.Add(column);
                }
            }

            // Add rows
            while (await reader.ReadAsync(cancellationToken).ConfigureAwait(false))
            {
                cancellationToken.ThrowIfCancellationRequested();

                var row = table.NewRow();
                for (int i = 0; i < reader.FieldCount; i++)
                {
                    row[i] = await reader.IsDBNullAsync(i, cancellationToken).ConfigureAwait(false)
                        ? DBNull.Value
                        : reader.GetValue(i);
                }
                table.Rows.Add(row);
            }

            return table;
        }
        
        
        
    }
}
```

## ParquetDataReader.cs
*Source: B:\Github\Parquet.Data.Ado\Parquet.Data.Ado\ParquetDataReader.cs*

```
using System;
using System.Buffers;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using Parquet;
using Parquet.Data;
using Parquet.Schema;

namespace Parquet.Data.Reader
{
    /// <summary>
    /// Represents a reader that provides fast, non-cached, forward-only access to Parquet data.
    /// Implements high-performance multi-threaded reading capabilities.
    /// </summary>
    public  class ParquetDataReader : IDataReader, IDataRecord, IDisposable, IAsyncDisposable
    {
        private readonly ParquetReader _reader;
        private ParquetRowGroupReader? _groupReader;
        private readonly SemaphoreSlim _lock = new SemaphoreSlim(1, 1);

        private Parquet.Data.DataColumn[]? _columns;
        private DataField[]? _fields;
        private int _currentRowGroup;
        private int _currentRow;
        private readonly bool _readNextGroup;
        private bool _disposed;

        /// <summary>
        /// Initializes a new instance of the ParquetDataReader class.
        /// </summary>
        /// <param name="reader">The Parquet reader.</param>
        /// <param name="currentRowGroup">The current row group.</param>
        /// <param name="readNextGroup">If set to true, reads the next group when current group is exhausted.</param>
        /// <exception cref="ArgumentNullException">Thrown when reader is null.</exception>
        public ParquetDataReader(ParquetReader reader, int currentRowGroup, bool readNextGroup)
        {
            ArgumentNullException.ThrowIfNull(reader);

            _reader = reader;
            _fields = reader.Schema.DataFields;
            _columns = new Parquet.Data.DataColumn[reader.Schema.Fields.Count];
            _currentRowGroup = currentRowGroup;
            _currentRow = -1;
            _readNextGroup = readNextGroup;
            _groupReader = reader.OpenRowGroupReader(_currentRowGroup);

            // Load columns synchronously in the constructor to ensure data is ready
            LoadColumnsAsync().GetAwaiter().GetResult();
        }

        /// <summary>
        /// Creates a new instance of ParquetDataReader asynchronously.
        /// </summary>
        /// <param name="reader">The Parquet reader.</param>
        /// <param name="currentRowGroup">The current row group.</param>
        /// <param name="readNextGroup">If set to true, reads the next group when current group is exhausted.</param>
        /// <param name="cancellationToken">Optional cancellation token.</param>
        /// <returns>A new ParquetDataReader instance.</returns>
        /// <exception cref="ArgumentNullException">Thrown when reader is null.</exception>
        public static async Task<ParquetDataReader> CreateAsync(
            ParquetReader reader,
            int currentRowGroup,
            bool readNextGroup,
            CancellationToken cancellationToken = default)
        {
            ArgumentNullException.ThrowIfNull(reader);

            var dataReader = new ParquetDataReader(reader, currentRowGroup, readNextGroup);
            await dataReader.LoadColumnsAsync(cancellationToken).ConfigureAwait(false);
            return dataReader;
        }

        /// <summary>
        /// Asynchronously loads all columns in parallel.
        /// </summary>
        /// <param name="cancellationToken">Optional cancellation token.</param>
        /// <returns>A task representing the asynchronous operation.</returns>
        internal async Task LoadColumnsAsync(CancellationToken cancellationToken = default)
        {
            await _lock.WaitAsync(cancellationToken).ConfigureAwait(false);

            try
            {
                if (_fields == null || _groupReader == null) return;

                // Sequential loading approach with proper error handling
                for (int i = 0; i < _fields.Length; i++)
                {
                    try
                    {
                        if (cancellationToken.IsCancellationRequested) break;

                        _columns![i] = await _groupReader.ReadColumnAsync(_fields[i], cancellationToken)
                            .ConfigureAwait(false);
                    }
                    catch (Exception ex)
                    {
                        string fieldName = _fields[i]?.Name ?? "unknown";
                        string fieldType = _fields[i]?.ClrType?.Name ?? "unknown";

                        throw new InvalidOperationException(
                            $"Error loading column {i} (Name: {fieldName}, Type: {fieldType}) " +
                            $"from row group {_currentRowGroup}.", ex);
                    }
                }
            }
            finally
            {
                _lock.Release();
            }
        }

        /// <summary>
        /// Advances the reader to the next result.
        /// </summary>
        /// <returns>true if there are more rows; otherwise false.</returns>
        public bool NextResult()
        {
            ThrowIfDisposed();
            _currentRowGroup++;
            if (_currentRowGroup >= _reader.RowGroupCount) return false;
            _currentRow = -1;
            _groupReader = _reader.OpenRowGroupReader(_currentRowGroup);
            // Load columns synchronously
            LoadColumnsAsync().GetAwaiter().GetResult();
            return true;
        }

        /// <summary>
        /// Asynchronously advances the reader to the next result.
        /// </summary>
        /// <param name="cancellationToken">Optional cancellation token.</param>
        /// <returns>true if there are more rows; otherwise false.</returns>
        public async Task<bool> NextResultAsync(CancellationToken cancellationToken = default)
        {
            ThrowIfDisposed();
            _currentRowGroup++;
            if (_currentRowGroup >= _reader.RowGroupCount) return false;
            _currentRow = -1;
            _groupReader = _reader.OpenRowGroupReader(_currentRowGroup);
            await LoadColumnsAsync(cancellationToken).ConfigureAwait(false);
            return true;
        }

        /// <summary>
        /// Returns a DataTable that describes the column metadata of the ParquetDataReader.
        /// </summary>
        /// <returns>A DataTable that describes the column metadata.</returns>
        public DataTable GetSchemaTable()
        {
            ThrowIfDisposed();

            DataTable schemaTable = new DataTable("SchemaTable");

            schemaTable.Columns.Add(SchemaTableColumn.ColumnName, typeof(string));
            schemaTable.Columns.Add(SchemaTableColumn.ColumnOrdinal, typeof(int));
            schemaTable.Columns.Add(SchemaTableColumn.ColumnSize, typeof(int));
            schemaTable.Columns.Add(SchemaTableColumn.DataType, typeof(Type));
            schemaTable.Columns.Add(SchemaTableColumn.AllowDBNull, typeof(bool));
            schemaTable.Columns.Add(SchemaTableColumn.IsUnique, typeof(bool));
            schemaTable.Columns.Add(SchemaTableColumn.IsKey, typeof(bool));

            for (int i = 0; i < _reader.Schema.Fields.Count; i++)
            {
                DataRow row = schemaTable.NewRow();
                row[SchemaTableColumn.ColumnName] = _reader.Schema.Fields[i].Name;
                row[SchemaTableColumn.ColumnOrdinal] = i;
                row[SchemaTableColumn.ColumnSize] = -1; // Unknown size
                row[SchemaTableColumn.DataType] = _reader.Schema.DataFields[i].ClrType;
                row[SchemaTableColumn.AllowDBNull] = true; // Assume nullable
                row[SchemaTableColumn.IsUnique] = false;   // Assume not unique
                row[SchemaTableColumn.IsKey] = false;      // Assume not primary key

                schemaTable.Rows.Add(row);
            }

            return schemaTable;
        }

        /// <summary>
        /// Gets the value of the specified column in its native format.
        /// </summary>
        /// <param name="i">The zero-based column ordinal.</param>
        /// <returns>The value of the specified column.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public object GetValue(int i)
        {
            ThrowIfDisposed();

            if (_columns == null) return DBNull.Value;
            if (i < 0 || i >= _columns.Length)
            {
                return DBNull.Value; // Instead of explicitly throwing IndexOutOfRangeException
            }

            return _columns[i]?.Data.GetValue(_currentRow) ?? DBNull.Value;
        }

        /// <summary>
        /// Advances the reader to the next record.
        /// </summary>
        /// <returns>true if there are more rows; otherwise false.</returns>
        public bool Read()
        {
            ThrowIfDisposed();

            _currentRow++;
            if (_groupReader == null) return false;

            if (_currentRow >= _groupReader.RowCount)
            {
                if (_readNextGroup)
                {
                    _currentRowGroup++;
                    if (_currentRowGroup >= _reader.RowGroupCount) return false;
                    _currentRow = 0;
                    _groupReader = _reader.OpenRowGroupReader(_currentRowGroup);
                    LoadColumnsAsync().GetAwaiter().GetResult();
                }
                else
                {
                    return false;
                }
            }
            return true;
        }

        /// <summary>
        /// Asynchronously advances the reader to the next record.
        /// </summary>
        /// <param name="cancellationToken">Optional cancellation token.</param>
        /// <returns>true if there are more rows; otherwise false.</returns>
        public async Task<bool> ReadAsync(CancellationToken cancellationToken = default)
        {
            ThrowIfDisposed();

            _currentRow++;
            if (_groupReader == null) return false;

            if (_currentRow >= _groupReader.RowCount)
            {
                if (_readNextGroup)
                {
                    _currentRowGroup++;
                    if (_currentRowGroup >= _reader.RowGroupCount) return false;
                    _currentRow = 0;
                    _groupReader = _reader.OpenRowGroupReader(_currentRowGroup);
                    await LoadColumnsAsync(cancellationToken).ConfigureAwait(false);
                }
                else
                {
                    return false;
                }
            }
            return true;
        }

        /// <summary>
        /// Gets the data type information for the specified field.
        /// </summary>
        /// <param name="i">The zero-based field ordinal.</param>
        /// <returns>The data type information for the specified field.</returns>
        public string GetDataTypeName(int i)
        {
            ThrowIfDisposed();

            if (_columns == null) return string.Empty;
            if (i < 0 || i >= _columns.Length)
            {
                return string.Empty; // Instead of explicitly throwing IndexOutOfRangeException
            }

            return _columns[i].Data.GetType().Name;
        }

        /// <summary>
        /// Gets the name for the field to find.
        /// </summary>
        /// <param name="i">The zero-based field ordinal.</param>
        /// <returns>The name of the field or the empty string (""), if there is no value to return.</returns>
        public string GetName(int i)
        {
            ThrowIfDisposed();

            if (_columns == null) return string.Empty;
            if (i < 0 || i >= _columns.Length)
            {
                return string.Empty; // Instead of explicitly throwing IndexOutOfRangeException
            }

            return _columns[i].Field.Name;
        }

        /// <summary>
        /// Returns the index of the named field.
        /// </summary>
        /// <param name="name">The name of the field to find.</param>
        /// <returns>The index of the named field.</returns>
        /// <exception cref="ArgumentNullException">Thrown when name is null.</exception>
        /// <exception cref="ArgumentException">Thrown when the column name is not found.</exception>
        public int GetOrdinal(string name)
        {
            ThrowIfDisposed();
            ArgumentNullException.ThrowIfNull(name);

            if (_columns == null)
            {
                throw new ArgumentException($"Column '{name}' not found", nameof(name));
            }

            // Optimize lookup with case-insensitive comparison
            int index = Array.FindIndex(_columns, x =>
                string.Equals(x.Field.Name, name, StringComparison.OrdinalIgnoreCase));

            if (index == -1)
            {
                throw new ArgumentException($"Column '{name}' not found", nameof(name));
            }

            return index;
        }

        /// <summary>
        /// Closes the ParquetDataReader object.
        /// </summary>
        public void Close()
        {
            if (_disposed) return;

            _groupReader?.Dispose();
            _groupReader = null;
            _disposed = true;
        }

        /// <summary>
        /// Releases all resources used by the ParquetDataReader.
        /// </summary>
        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Releases the unmanaged resources used by the ParquetDataReader and optionally releases the managed resources.
        /// </summary>
        /// <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        protected virtual void Dispose(bool disposing)
        {
            if (_disposed) return;

            if (disposing)
            {
                // First dispose the group reader
                if (_groupReader != null)
                {
                    _groupReader.Dispose();
                    _groupReader = null;
                }

                // Then dispose the reader - Make sure we're disposing this correctly
                if (_reader != null)
                {
                    // Ensure the underlying stream gets closed properly
                    _reader.Dispose();
                }

                // Finally dispose the lock
                _lock?.Dispose();
            }

            _columns = null;
            _fields = null;
            _disposed = true;
        }

        /// <summary>
        /// Asynchronously releases all resources used by the ParquetDataReader.
        /// </summary>
        /// <returns>A task representing the asynchronous dispose operation.</returns>
        public async ValueTask DisposeAsync()
        {
            if (_disposed) return;

            if (_groupReader != null)
            {
                await Task.Run(() => _groupReader.Dispose()).ConfigureAwait(false);
                _groupReader = null;
            }

            if (_reader != null)
            {
                await Task.Run(() => _reader.Dispose()).ConfigureAwait(false);
            }

            if (_lock != null)
            {
                _lock.Dispose();
            }

            _columns = null;
            _fields = null;
            _disposed = true;

            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Asynchronously releases the managed resources used by the ParquetDataReader.
        /// </summary>
        /// <returns>A task representing the asynchronous dispose operation.</returns>
        private async ValueTask DisposeAsyncCore()
        {
            if (_disposed) return;

            if (_groupReader != null)
            {
                await Task.Run(() => _groupReader.Dispose()).ConfigureAwait(false);
            }

            if (_reader != null)
            {
                await Task.Run(() => _reader.Dispose()).ConfigureAwait(false);
            }

            if (_lock != null)
            {
                _lock.Dispose();
            }
        }

        /// <summary>
        /// Throws an ObjectDisposedException if the reader is disposed.
        /// </summary>
        /// <exception cref="ObjectDisposedException">Thrown when the reader is disposed.</exception>
        internal void ThrowIfDisposed()
        {
            ObjectDisposedException.ThrowIf(_disposed, this);
        }

        // Properties:

        /// <summary>
        /// Gets the depth of nesting for the current row.
        /// </summary>
        public int Depth => _currentRowGroup;

        /// <summary>
        /// Gets the number of columns in the current row.
        /// </summary>
        public int FieldCount
        {
            get
            {
                ThrowIfDisposed();
                return _columns?.Length ?? 0;
            }
        }

        /// <summary>
        /// Gets the column with the specified index.
        /// </summary>
        /// <param name="i">The zero-based column ordinal.</param>
        /// <returns>The column with the specified index.</returns>
        public object this[int i] => GetValue(i);

        /// <summary>
        /// Gets the column with the specified name.
        /// </summary>
        /// <param name="name">The name of the column to find.</param>
        /// <returns>The column with the specified name.</returns>
        public object this[string name] => GetValue(GetOrdinal(name));

        /// <summary>
        /// Gets a value indicating whether the data reader is closed.
        /// </summary>
        public bool IsClosed => _disposed;

        /// <summary>
        /// Gets the number of rows changed, inserted, or deleted by execution of the SQL statement.
        /// </summary>
        /// <exception cref="NotSupportedException">Always thrown because this property is not supported.</exception>
        public int RecordsAffected => throw new NotSupportedException("RecordsAffected is not supported for read-only data.");

        // --------------------------------------------------------------------------------
        // Type-specific methods for accessing column values (with safer edge-case handling):
        // --------------------------------------------------------------------------------

        /// <summary>
        /// Retrieves the value of the specified column as a <see cref="bool"/>.
        /// </summary>
        /// <param name="i">The zero-based column ordinal.</param>
        /// <returns>The value of the column as a <see cref="bool"/>.</returns>
        /// <exception cref="ObjectDisposedException">Thrown if the reader is disposed.</exception>
        /// <exception cref="InvalidCastException">
        /// Thrown if the value cannot be converted to a <see cref="bool"/>, 
        /// or if the value is <see cref="DBNull"/>.
        /// </exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool GetBoolean(int i)
        {
            ThrowIfDisposed();
            object value = GetValue(i);
            if (value == DBNull.Value)
                throw new InvalidCastException("Cannot convert DBNull to Boolean");

            try
            {
                return Convert.ToBoolean(value, CultureInfo.InvariantCulture);
            }
            catch (Exception ex) when (ex is FormatException or InvalidCastException or OverflowException)
            {
                throw CreateInvalidCastException(i, value, "Boolean", ex);
            }
        }

        /// <summary>
        /// Retrieves the value of the specified column as a <see cref="byte"/>.
        /// </summary>
        /// <param name="i">The zero-based column ordinal.</param>
        /// <returns>The value of the specified column as a <see cref="byte"/>.</returns>
        /// <exception cref="ObjectDisposedException">Thrown if the reader is disposed.</exception>
        /// <exception cref="InvalidCastException">
        /// Thrown if the value cannot be converted to a <see cref="byte"/> due to an invalid type, format, or overflow.
        /// </exception>
        /// <exception cref="IndexOutOfRangeException">Thrown if the column index is out of range.</exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public byte GetByte(int i)
        {
            ThrowIfDisposed();
            object value = GetValue(i);
            if (value == DBNull.Value)
                throw new InvalidCastException("Cannot convert DBNull to Byte");

            try
            {
                return Convert.ToByte(value, CultureInfo.InvariantCulture);
            }
            catch (Exception ex) when (ex is FormatException or InvalidCastException or OverflowException)
            {
                throw CreateInvalidCastException(i, value, "Byte", ex);
            }
        }


        /// <summary>
        /// Reads a sequence of bytes from the specified column, starting at the specified field offset, 
        /// and writes them into the provided buffer starting at the specified buffer offset.
        /// </summary>
        /// <param name="i">The zero-based column ordinal.</param>
        /// <param name="fieldOffset">The index within the field from which to begin the read operation.</param>
        /// <param name="buffer">
        /// The buffer into which the bytes will be copied. If <c>null</c>, the method returns the length of the byte array.
        /// </param>
        /// <param name="bufferoffset">The zero-based index in the buffer at which to begin writing the data.</param>
        /// <param name="length">The maximum number of bytes to copy into the buffer.</param>
        /// <returns>
        /// The actual number of bytes read and copied into the buffer. If <paramref name="buffer"/> is <c>null</c>, 
        /// the total length of the byte array in the specified column is returned.
        /// </returns>
        /// <exception cref="InvalidCastException">
        /// Thrown if the value in the specified column is not of type .
        /// </exception>
        /// <exception cref="IndexOutOfRangeException">
        /// Thrown if the column index is out of range.
        /// </exception>
        /// <exception cref="ObjectDisposedException">
        /// Thrown if the reader has been disposed.
        /// </exception>
        public long GetBytes(int i, long fieldOffset, byte[]? buffer, int bufferoffset, int length)
        {
            ThrowIfDisposed();
            object value = GetValue(i);

            if (value == DBNull.Value) return 0;

            if (value is not byte[] bytes)
            {
                throw CreateInvalidCastException(i, value, "byte[]");
            }

            if (buffer == null) return bytes.Length;

            var bytesToCopy = (int)Math.Min(length, bytes.Length - fieldOffset);
            if (bytesToCopy <= 0) return 0;

            Buffer.BlockCopy(bytes, (int)fieldOffset, buffer, bufferoffset, bytesToCopy);
            return bytesToCopy;
        }

        /// <summary>
        /// Retrieves the value of the specified column as a <see cref="char"/>.
        /// </summary>
        /// <param name="i">The zero-based column ordinal.</param>
        /// <returns>The value of the specified column as a <see cref="char"/>.</returns>
        /// <exception cref="ObjectDisposedException">Thrown if the reader is disposed.</exception>
        /// <exception cref="InvalidCastException">
        /// Thrown if the value cannot be converted to a <see cref="char"/> or if the value is <see cref="DBNull"/>.
        /// </exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public char GetChar(int i)
        {
            ThrowIfDisposed();
            object value = GetValue(i);
            if (value == DBNull.Value)
                throw new InvalidCastException("Cannot convert DBNull to Char");

            try
            {
                return Convert.ToChar(value, CultureInfo.InvariantCulture);
            }
            catch (Exception ex) when (ex is FormatException or InvalidCastException or OverflowException)
            {
                throw CreateInvalidCastException(i, value, "Char", ex);
            }
        }

        /// <summary>
        /// Reads a stream of characters from the specified column offset into the buffer as an array, 
        /// starting at the given buffer offset.
        /// </summary>
        /// <param name="i">The zero-based column ordinal.</param>
        /// <param name="fieldoffset">The index within the field from which to begin the read operation.</param>
        /// <param name="buffer">
        /// The buffer into which to copy the data. If <c>null</c>, the method returns the length of the field in characters.
        /// </param>
        /// <param name="bufferoffset">The index within the buffer at which to start placing the data.</param>
        /// <param name="length">The maximum number of characters to read.</param>
        /// <returns>
        /// The actual number of characters read. If <paramref name="buffer"/> is <c>null</c>, 
        /// the total length of the field in characters is returned.
        /// </returns>
        /// <exception cref="InvalidCastException">
        /// Thrown if the value of the specified column is not of type 
        /// </exception>
        /// <exception cref="ObjectDisposedException">
        /// Thrown if the reader has been disposed.
        /// </exception>
        public long GetChars(int i, long fieldoffset, char[]? buffer, int bufferoffset, int length)
        {
            ThrowIfDisposed();
            object value = GetValue(i);

            if (value == DBNull.Value) return 0;

            char[] chars;
            if (value is char[] charArray)
            {
                chars = charArray;
            }
            else if (value is string str)
            {
                chars = str.ToCharArray();
            }
            else
            {
                throw CreateInvalidCastException(i, value, "char[] or string");
            }

            if (buffer == null) return chars.Length;

            var charsToCopy = (int)Math.Min(length, chars.Length - fieldoffset);
            if (charsToCopy <= 0) return 0;

            Array.Copy(chars, fieldoffset, buffer, bufferoffset, charsToCopy);
            return charsToCopy;
        }

        /// <summary>
        /// Retrieves an <see cref="IDataReader"/> for the specified column ordinal.
        /// </summary>
        /// <param name="i">The zero-based column ordinal.</param>
        /// <returns>An <see cref="IDataReader"/> for the specified column.</returns>
        /// <exception cref="ObjectDisposedException">Thrown if the reader is disposed.</exception>
        /// <exception cref="NotSupportedException">Thrown because this method is not supported for Parquet data.</exception>
        public IDataReader GetData(int i)
        {
            ThrowIfDisposed();
            throw new NotSupportedException("GetData is not supported for Parquet data.");
        }

        /// <summary>
        /// Retrieves the value of the specified column as a <see cref="DateTime"/> object.
        /// </summary>
        /// <param name="i">The zero-based column ordinal.</param>
        /// <returns>The value of the specified column as a <see cref="DateTime"/>.</returns>
        /// <exception cref="ObjectDisposedException">Thrown if the reader is disposed.</exception>
        /// <exception cref="InvalidCastException">
        /// Thrown if the value cannot be converted to a <see cref="DateTime"/> or if the value is <see cref="DBNull"/>.
        /// </exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public DateTime GetDateTime(int i)
        {
            ThrowIfDisposed();
            object value = GetValue(i);
            if (value == DBNull.Value)
                throw new InvalidCastException("Cannot convert DBNull to DateTime");

            try
            {
                return Convert.ToDateTime(value, CultureInfo.InvariantCulture);
            }
            catch (Exception ex) when (ex is FormatException or InvalidCastException or OverflowException)
            {
                throw CreateInvalidCastException(i, value, "DateTime", ex);
            }
        }

        /// <summary>
        /// Retrieves the value of the specified column as a <see cref="decimal"/>.
        /// </summary>
        /// <param name="i">The zero-based column ordinal.</param>
        /// <returns>The value of the specified column as a <see cref="decimal"/>.</returns>
        /// <exception cref="ObjectDisposedException">Thrown if the reader is disposed.</exception>
        /// <exception cref="InvalidCastException">
        /// Thrown if the value cannot be converted to a <see cref="decimal"/> or if the value is <see cref="DBNull"/>.
        /// </exception>
        /// <exception cref="FormatException">Thrown if the value is not in a valid format for a <see cref="decimal"/>.</exception>
        /// <exception cref="OverflowException">Thrown if the value is outside the range of a <see cref="decimal"/>.</exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public decimal GetDecimal(int i)
        {
            ThrowIfDisposed();
            object value = GetValue(i);
            if (value == DBNull.Value)
                throw new InvalidCastException("Cannot convert DBNull to Decimal");

            try
            {
                return Convert.ToDecimal(value, CultureInfo.InvariantCulture);
            }
            catch (Exception ex) when (ex is FormatException or InvalidCastException or OverflowException)
            {
                throw CreateInvalidCastException(i, value, "Decimal", ex);
            }
        }

        /// <summary>
        /// Retrieves the value of the specified column as a <see cref="double"/>.
        /// </summary>
        /// <param name="i">The zero-based column ordinal.</param>
        /// <returns>The value of the specified column as a <see cref="double"/>.</returns>
        /// <exception cref="ObjectDisposedException">Thrown if the reader is disposed.</exception>
        /// <exception cref="InvalidCastException">
        /// Thrown if the value cannot be converted to a <see cref="double"/>, 
        /// or if the value is <see cref="DBNull"/>.
        /// </exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public double GetDouble(int i)
        {
            ThrowIfDisposed();
            object value = GetValue(i);
            if (value == DBNull.Value)
                throw new InvalidCastException("Cannot convert DBNull to Double");

            try
            {
                return Convert.ToDouble(value, CultureInfo.InvariantCulture);
            }
            catch (Exception ex) when (ex is FormatException or InvalidCastException or OverflowException)
            {
                throw CreateInvalidCastException(i, value, "Double", ex);
            }
        }

        /// <summary>
        /// Retrieves the data type of the specified column in the current row.
        /// </summary>
        /// <param name="i">The zero-based column ordinal.</param>
        /// <returns>
        /// A <see cref="Type"/> object representing the data type of the column.
        /// If the column index is out of range or the column metadata is unavailable, 
        /// the method returns <see cref="object"/>.
        /// </returns>
        /// <exception cref="ObjectDisposedException">Thrown if the reader has been disposed.</exception>
        public Type GetFieldType(int i)
        {
            ThrowIfDisposed();

            if (_columns == null) return typeof(object);
            if (i < 0 || i >= _columns.Length)
            {
                return typeof(object); // Instead of explicitly throwing IndexOutOfRangeException
            }

            return _columns[i].Field.ClrType ?? typeof(object);
        }

        /// <summary>
        /// Retrieves the value of the specified column as a <see cref="float"/> (Single).
        /// </summary>
        /// <param name="i">The zero-based column ordinal.</param>
        /// <returns>The value of the specified column as a <see cref="float"/>.</returns>
        /// <exception cref="ObjectDisposedException">Thrown if the reader is disposed.</exception>
        /// <exception cref="InvalidCastException">
        /// Thrown if the value cannot be converted to a <see cref="float"/>, 
        /// or if the value is <see cref="DBNull"/>.
        /// </exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public float GetFloat(int i)
        {
            ThrowIfDisposed();
            object value = GetValue(i);
            if (value == DBNull.Value)
                throw new InvalidCastException("Cannot convert DBNull to Single");

            try
            {
                return Convert.ToSingle(value, CultureInfo.InvariantCulture);
            }
            catch (Exception ex) when (ex is FormatException or InvalidCastException or OverflowException)
            {
                throw CreateInvalidCastException(i, value, "Single (float)", ex);
            }
        }

        /// <summary>
        /// Retrieves the value of the specified column as a <see cref="Guid"/>.
        /// </summary>
        /// <param name="i">The zero-based column ordinal.</param>
        /// <returns>The value of the specified column as a <see cref="Guid"/>.</returns>
        /// <exception cref="ObjectDisposedException">Thrown if the reader is disposed.</exception>
        /// <exception cref="InvalidCastException">
        /// Thrown if the value cannot be converted to a <see cref="Guid"/>. This includes cases where:
        /// <list type="bullet">
        /// <item>The value is <see cref="DBNull"/>.</item>
        /// <item>The value is a byte array but not 16 bytes in length.</item>
        /// <item>The value is a string that cannot be parsed as a <see cref="Guid"/>.</item>
        /// </list>
        /// </exception>
        public Guid GetGuid(int i)
        {
            ThrowIfDisposed();
            object value = GetValue(i);
            if (value == DBNull.Value)
                throw new InvalidCastException("Cannot convert DBNull to Guid");

            // Attempt direct/known conversions first
            if (value is Guid guid) return guid;

            if (value is byte[] bytes)
            {
                if (bytes.Length == 16)
                {
                    return new Guid(bytes);
                }
                throw CreateInvalidCastException(i, value, "Guid (expected 16-byte array)");
            }

            if (value is string str)
            {
                try
                {
                    return Guid.Parse(str);
                }
                catch (FormatException ex)
                {
                    throw new InvalidCastException(
                        $"Cannot convert string to Guid. ColumnIndex={i}, Value='{str}'.", ex);
                }
            }

            throw CreateInvalidCastException(i, value, "Guid");
        }

        /// <summary>
        /// Retrieves the 16-bit signed integer (short) value of the specified column.
        /// </summary>
        /// <param name="i">The zero-based column ordinal.</param>
        /// <returns>The 16-bit signed integer (short) value of the specified column.</returns>
        /// <exception cref="ObjectDisposedException">Thrown if the reader is disposed.</exception>
        /// <exception cref="InvalidCastException">
        /// Thrown when the value in the specified column cannot be converted to a 16-bit signed integer.
        /// This can occur if the value is <see cref="DBNull"/> or if the conversion fails due to format issues, 
        /// type mismatches, or overflow.
        /// </exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public short GetInt16(int i)
        {
            ThrowIfDisposed();
            object value = GetValue(i);
            if (value == DBNull.Value)
                throw new InvalidCastException("Cannot convert DBNull to Int16");

            try
            {
                return Convert.ToInt16(value, CultureInfo.InvariantCulture);
            }
            catch (Exception ex) when (ex is FormatException or InvalidCastException or OverflowException)
            {
                throw CreateInvalidCastException(i, value, "Int16", ex);
            }
        }

        /// <summary>
        /// Retrieves the value of the specified column as a 32-bit signed integer.
        /// </summary>
        /// <param name="i">The zero-based column ordinal.</param>
        /// <returns>The value of the specified column as an <see cref="int"/>.</returns>
        /// <exception cref="ObjectDisposedException">Thrown if the reader is disposed.</exception>
        /// <exception cref="InvalidCastException">
        /// Thrown if the value cannot be converted to a 32-bit signed integer, 
        /// or if the value is <see cref="DBNull.Value"/>.
        /// </exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetInt32(int i)
        {
            ThrowIfDisposed();
            object value = GetValue(i);
            if (value == DBNull.Value)
                throw new InvalidCastException("Cannot convert DBNull to Int32");

            try
            {
                return Convert.ToInt32(value, CultureInfo.InvariantCulture);
            }
            catch (Exception ex) when (ex is FormatException or InvalidCastException or OverflowException)
            {
                throw CreateInvalidCastException(i, value, "Int32", ex);
            }
        }

        /// <summary>
        /// Retrieves the 64-bit signed integer (Int64) value of the specified column.
        /// </summary>
        /// <param name="i">The zero-based column ordinal.</param>
        /// <returns>The 64-bit signed integer value of the specified column.</returns>
        /// <exception cref="ObjectDisposedException">Thrown if the reader has been disposed.</exception>
        /// <exception cref="InvalidCastException">
        /// Thrown if the value cannot be converted to a 64-bit signed integer, 
        /// or if the value is <see cref="DBNull.Value"/>.
        /// </exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public long GetInt64(int i)
        {
            ThrowIfDisposed();
            object value = GetValue(i);
            if (value == DBNull.Value)
                throw new InvalidCastException("Cannot convert DBNull to Int64");

            try
            {
                return Convert.ToInt64(value, CultureInfo.InvariantCulture);
            }
            catch (Exception ex) when (ex is FormatException or InvalidCastException or OverflowException)
            {
                throw CreateInvalidCastException(i, value, "Int64", ex);
            }
        }

        /// <summary>
        /// Retrieves the value of the specified column as a <see cref="string"/>.
        /// </summary>
        /// <param name="i">The zero-based column ordinal.</param>
        /// <returns>The value of the specified column as a <see cref="string"/>.</returns>
        /// <exception cref="ObjectDisposedException">Thrown if the reader is disposed.</exception>
        /// <exception cref="InvalidCastException">
        /// Thrown if the value of the specified column cannot be cast to a <see cref="string"/>.
        /// </exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public string GetString(int i)
        {
            ThrowIfDisposed();
            object value = GetValue(i);
            if (value == DBNull.Value)
                throw new InvalidCastException("Cannot convert DBNull to String");

            // .ToString() typically won't throw, but let's keep it consistent if ever changed
            try
            {
                return value.ToString() ?? string.Empty;
            }
            catch (Exception ex)
            {
                throw CreateInvalidCastException(i, value, "String", ex);
            }
        }

        /// <summary>
        /// Populates the provided array with the values of the current row's fields.
        /// </summary>
        /// <param name="values">
        /// An array of <see cref="object"/> to hold the field values of the current row. 
        /// The array must have a length equal to or greater than the number of fields in the current row.
        /// </param>
        /// <returns>
        /// The number of field values copied into the <paramref name="values"/> array. 
        /// This will be the lesser of the array's length or the number of fields in the current row.
        /// </returns>
        /// <exception cref="ObjectDisposedException">
        /// Thrown if the <see cref="ParquetDataReader"/> has been disposed.
        /// </exception>
        /// <exception cref="ArgumentNullException">
        /// Thrown if the <paramref name="values"/> array is <c>null</c>.
        /// </exception>
        public int GetValues(object[] values)
        {
            ThrowIfDisposed();
            ArgumentNullException.ThrowIfNull(values);

            int count = Math.Min(values.Length, FieldCount);
            for (int i = 0; i < count; i++)
            {
                values[i] = GetValue(i);
            }
            return count;
        }

        /// <summary>
        /// Asynchronously retrieves all the attribute values of the current record into the provided array.
        /// </summary>
        /// <param name="values">
        /// An array of <see cref="object"/> to hold the attribute values of the current record.
        /// The length of the array should be sufficient to hold all the fields, or it will be truncated to the number of fields.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="CancellationToken"/> to observe while waiting for the task to complete.
        /// </param>
        /// <returns>
        /// A task that represents the asynchronous operation. The task result contains the number of values copied into the array.
        /// </returns>
        /// <exception cref="ObjectDisposedException">
        /// Thrown if the reader has been disposed.
        /// </exception>
        /// <exception cref="ArgumentNullException">
        /// Thrown if the <paramref name="values"/> array is null.
        /// </exception>
        public Task<int> GetValuesAsync(object[] values, CancellationToken cancellationToken = default)
        {
            ThrowIfDisposed();
            ArgumentNullException.ThrowIfNull(values);

            int count = Math.Min(values.Length, FieldCount);
            for (int i = 0; i < count; i++)
            {
                values[i] = GetValue(i);
            }
            return Task.FromResult(count);
        }

        /// <summary>
        /// Determines whether the specified column contains a DBNull value.
        /// </summary>
        /// <param name="i">The zero-based column ordinal.</param>
        /// <returns>
        /// <c>true</c> if the specified column contains a DBNull value or if the column index is out of range; 
        /// otherwise, <c>false</c>.
        /// </returns>
        /// <exception cref="ObjectDisposedException">Thrown when the reader is disposed.</exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsDBNull(int i)
        {
            ThrowIfDisposed();

            if (_columns == null) return true;
            if (i < 0 || i >= _columns.Length)
            {
                return true; // Instead of explicitly throwing IndexOutOfRangeException
            }

            object value = GetValue(i);
            return value == null || Convert.IsDBNull(value);
        }

        /// <summary>
        /// Asynchronously determines whether the column at the specified ordinal contains a DBNull value.
        /// </summary>
        /// <param name="i">The zero-based column ordinal.</param>
        /// <param name="cancellationToken">
        /// A <see cref="CancellationToken"/> that can be used to cancel the asynchronous operation.
        /// </param>
        /// <returns>
        /// A task that represents the asynchronous operation. The task result contains <c>true</c> if the specified column is equivalent to <see cref="DBNull"/> or is null; otherwise, <c>false</c>.
        /// </returns>
        /// <exception cref="ObjectDisposedException">Thrown if the reader has been disposed.</exception>
        /// <exception cref="IndexOutOfRangeException">Thrown if the column index is out of range.</exception>
        public Task<bool> IsDBNullAsync(int i, CancellationToken cancellationToken = default)
        {
            return Task.FromResult(IsDBNull(i));
        }

        // Helper to unify creation of detailed InvalidCastException:
        private InvalidCastException CreateInvalidCastException(
            int columnIndex,
            object value,
            string targetType,
            Exception? innerException = null)
        {
            string message =
                $"Error converting column {columnIndex} ('{GetName(columnIndex)}') " +
                $"from {value.GetType().Name} to {targetType}. Value: {value}";
            return new InvalidCastException(message, innerException);
        }
    }
}

```

## ParquetDataReaderFactory.cs
*Source: B:\Github\Parquet.Data.Ado\Parquet.Data.Ado\ParquetDataReaderFactory.cs*

```
using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using Parquet;

namespace Parquet.Data.Reader
{
    /// <summary>
    /// Factory class for creating ParquetDataReader instances.
    /// Provides convenient methods for creating readers from files or streams.
    /// </summary>
    public static class ParquetDataReaderFactory
    {
        /// <summary>
        /// Creates a new ParquetDataReader instance from a file path.
        /// </summary>
        /// <param name="filePath">The path to the Parquet file.</param>
        /// <param name="readNextGroup">If set to true, reads the next group when the current group is exhausted.</param>
        /// <param name="parquetOptions">Optional ParquetOptions to configure the reader.</param>
        /// <returns>A new ParquetDataReader instance.</returns>
        /// <exception cref="ArgumentNullException">Thrown when filePath is null.</exception>
        /// <exception cref="FileNotFoundException">Thrown when the file does not exist.</exception>
        public static ParquetDataReader Create(
            string filePath,
            bool readNextGroup = true,
            ParquetOptions? parquetOptions = null)
        {
            ArgumentNullException.ThrowIfNull(filePath);

            if (!System.IO.File.Exists(filePath))
                throw new FileNotFoundException("Parquet file not found", filePath);

            // Open the file synchronously
            var stream = System.IO.File.OpenRead(filePath);

            // Use the asynchronous factory method and block synchronously.
            var reader = ParquetReader
                .CreateAsync(stream, parquetOptions, leaveStreamOpen: false, cancellationToken: CancellationToken.None)
                .ConfigureAwait(false)
                .GetAwaiter()
                .GetResult();

            return new ParquetDataReader(reader, 0, readNextGroup);
        }

        /// <summary>
        /// Asynchronously creates a new ParquetDataReader instance from a file path.
        /// </summary>
        /// <param name="filePath">The path to the Parquet file.</param>
        /// <param name="readNextGroup">If set to true, reads the next group when the current group is exhausted.</param>
        /// <param name="parquetOptions">Optional ParquetOptions to configure the reader.</param>
        /// <param name="cancellationToken">Optional cancellation token.</param>
        /// <returns>A new ParquetDataReader instance.</returns>
        /// <exception cref="ArgumentNullException">Thrown when filePath is null.</exception>
        /// <exception cref="FileNotFoundException">Thrown when the file does not exist.</exception>
        public static async Task<ParquetDataReader> CreateAsync(
            string filePath,
            bool readNextGroup = true,
            ParquetOptions? parquetOptions = null,
            CancellationToken cancellationToken = default)
        {
            ArgumentNullException.ThrowIfNull(filePath);

            if (!System.IO.File.Exists(filePath))
                throw new FileNotFoundException("Parquet file not found", filePath);

            // Open file asynchronously.
            var stream = new FileStream(
                filePath,
                FileMode.Open,
                FileAccess.Read,
                FileShare.Read,
                bufferSize: 4096,
                useAsync: true);

            var reader = await ParquetReader
                .CreateAsync(stream, parquetOptions, leaveStreamOpen: false, cancellationToken)
                .ConfigureAwait(false);

            return await ParquetDataReader
                .CreateAsync(reader, 0, readNextGroup, cancellationToken)
                .ConfigureAwait(false);
        }

        /// <summary>
        /// Creates a new ParquetDataReader instance from a stream.
        /// </summary>
        /// <param name="stream">The stream containing Parquet data.</param>
        /// <param name="readNextGroup">If set to true, reads the next group when the current group is exhausted.</param>
        /// <param name="leaveOpen">If set to true, leaves the stream open after the reader is disposed.</param>
        /// <param name="parquetOptions">Optional ParquetOptions to configure the reader.</param>
        /// <returns>A new ParquetDataReader instance.</returns>
        /// <exception cref="ArgumentNullException">Thrown when stream is null.</exception>
        public static ParquetDataReader Create(
            Stream stream,
            bool readNextGroup = true,
            bool leaveOpen = false,
            ParquetOptions? parquetOptions = null)
        {
            ArgumentNullException.ThrowIfNull(stream);

            var reader = ParquetReader
                .CreateAsync(stream, parquetOptions, leaveStreamOpen: leaveOpen, cancellationToken: CancellationToken.None)
                .ConfigureAwait(false)
                .GetAwaiter()
                .GetResult();

            return new ParquetDataReader(reader, 0, readNextGroup);
        }

        /// <summary>
        /// Asynchronously creates a new ParquetDataReader instance from a stream.
        /// </summary>
        /// <param name="stream">The stream containing Parquet data.</param>
        /// <param name="readNextGroup">If set to true, reads the next group when the current group is exhausted.</param>
        /// <param name="leaveOpen">If set to true, leaves the stream open after the reader is disposed.</param>
        /// <param name="parquetOptions">Optional ParquetOptions to configure the reader.</param>
        /// <param name="cancellationToken">Optional cancellation token.</param>
        /// <returns>A new ParquetDataReader instance.</returns>
        /// <exception cref="ArgumentNullException">Thrown when stream is null.</exception>
        public static async Task<ParquetDataReader> CreateAsync(
            Stream stream,
            bool readNextGroup = true,
            bool leaveOpen = false,
            ParquetOptions? parquetOptions = null,
            CancellationToken cancellationToken = default)
        {
            ArgumentNullException.ThrowIfNull(stream);

            var reader = await ParquetReader
                .CreateAsync(stream, parquetOptions, leaveStreamOpen: leaveOpen, cancellationToken)
                .ConfigureAwait(false);

            return await ParquetDataReader
                .CreateAsync(reader, 0, readNextGroup, cancellationToken)
                .ConfigureAwait(false);
        }

        /// <summary>
        /// Creates multiple ParquetDataReader instances in parallel from a collection of file paths.
        /// </summary>
        /// <param name="filePaths">The paths to the Parquet files.</param>
        /// <param name="readNextGroup">If set to true, reads the next group when the current group is exhausted.</param>
        /// <param name="parquetOptions">Optional ParquetOptions to configure the reader.</param>
        /// <param name="maxDegreeOfParallelism">Maximum number of readers to create in parallel. Default is Environment.ProcessorCount.</param>
        /// <param name="cancellationToken">Optional cancellation token.</param>
        /// <returns>An array of ParquetDataReader instances.</returns>
        public static async Task<ParquetDataReader[]> CreateManyAsync(
            string[] filePaths,
            bool readNextGroup = true,
            ParquetOptions? parquetOptions = null,
            int maxDegreeOfParallelism = 0,
            CancellationToken cancellationToken = default)
        {
            ArgumentNullException.ThrowIfNull(filePaths);

            if (maxDegreeOfParallelism <= 0)
            {
                maxDegreeOfParallelism = Environment.ProcessorCount;
            }

            using var semaphore = new SemaphoreSlim(maxDegreeOfParallelism);
            var tasks = new Task<ParquetDataReader>[filePaths.Length];

            for (int i = 0; i < filePaths.Length; i++)
            {
                var filePath = filePaths[i];
                tasks[i] = CreateReaderAsync(filePath);
            }

            // Local function that handles semaphore and calls CreateAsync for a filePath
            async Task<ParquetDataReader> CreateReaderAsync(string filePath)
            {
                await semaphore.WaitAsync(cancellationToken).ConfigureAwait(false);
                try
                {
                    // Use the existing CreateAsync method for actual file reading
                    return await CreateAsync(filePath, readNextGroup, parquetOptions, cancellationToken)
                        .ConfigureAwait(false);
                }
                finally
                {
                    semaphore.Release();
                }
            }

            return await Task.WhenAll(tasks).ConfigureAwait(false);
        }
    }
}

```

## ParquetDataReaderFactoryExtensions.cs
*Source: B:\Github\Parquet.Data.Ado\Parquet.Data.Ado\ParquetDataReaderFactoryExtensions.cs*

```
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Parquet;
using System.IO;

namespace Parquet.Data.Reader
{
    /// <summary>
    /// Extension methods for the ParquetDataReaderFactory to support creating readers with virtual columns.
    /// </summary>
    public static class ParquetDataReaderFactoryExtensions
    {
        /// <summary>
        /// Creates a new ParquetDataReaderWithVirtualColumns instance from a file path.
        /// </summary>
        /// <param name="filePath">The path to the Parquet file.</param>
        /// <param name="virtualColumns">Collection of virtual columns to include in the reader.</param>
        /// <param name="readNextGroup">If set to true, reads the next group when the current group is exhausted.</param>
        /// <param name="parquetOptions">Optional ParquetOptions to configure the reader.</param>
        /// <returns>A new ParquetDataReaderWithVirtualColumns instance.</returns>
        /// <exception cref="ArgumentNullException">Thrown when filePath is null.</exception>
        /// <exception cref="FileNotFoundException">Thrown when the file does not exist.</exception>
        public static ParquetDataReaderWithVirtualColumns CreateWithVirtualColumns(
            string filePath,
            IEnumerable<VirtualColumn> virtualColumns,
            bool readNextGroup = true,
            ParquetOptions? parquetOptions = null)
        {
            ArgumentNullException.ThrowIfNull(filePath);
            ArgumentNullException.ThrowIfNull(virtualColumns);

            if (!System.IO.File.Exists(filePath))
                throw new FileNotFoundException("Parquet file not found", filePath);

            // Open the file synchronously
            var stream = System.IO.File.OpenRead(filePath);

            // Use the asynchronous factory method and block synchronously
            var reader = ParquetReader
                .CreateAsync(stream, parquetOptions, leaveStreamOpen: false, cancellationToken: CancellationToken.None)
                .ConfigureAwait(false)
                .GetAwaiter()
                .GetResult();

            // Prepare sorted list of virtual columns
            var virtualColumnList = PrepareSortedVirtualColumns(virtualColumns, reader.Schema.Fields.Count);

            return new ParquetDataReaderWithVirtualColumns(reader, 0, readNextGroup, virtualColumnList);
        }

        /// <summary>
        /// Asynchronously creates a new ParquetDataReaderWithVirtualColumns instance from a file path.
        /// </summary>
        /// <param name="filePath">The path to the Parquet file.</param>
        /// <param name="virtualColumns">Collection of virtual columns to include in the reader.</param>
        /// <param name="readNextGroup">If set to true, reads the next group when the current group is exhausted.</param>
        /// <param name="parquetOptions">Optional ParquetOptions to configure the reader.</param>
        /// <param name="cancellationToken">Optional cancellation token.</param>
        /// <returns>A task representing the asynchronous operation.</returns>
        /// <exception cref="ArgumentNullException">Thrown when filePath is null.</exception>
        /// <exception cref="FileNotFoundException">Thrown when the file does not exist.</exception>
        public static async Task<ParquetDataReaderWithVirtualColumns> CreateWithVirtualColumnsAsync(
            string filePath,
            IEnumerable<VirtualColumn> virtualColumns,
            bool readNextGroup = true,
            ParquetOptions? parquetOptions = null,
            CancellationToken cancellationToken = default)
        {
            ArgumentNullException.ThrowIfNull(filePath);
            ArgumentNullException.ThrowIfNull(virtualColumns);

            if (!System.IO.File.Exists(filePath))
                throw new FileNotFoundException("Parquet file not found", filePath);

            // Open file asynchronously
            var stream = new FileStream(
                filePath,
                FileMode.Open,
                FileAccess.Read,
                FileShare.Read,
                bufferSize: 4096,
                useAsync: true);

            var reader = await ParquetReader
                .CreateAsync(stream, parquetOptions, leaveStreamOpen: false, cancellationToken)
                .ConfigureAwait(false);

            // Prepare sorted list of virtual columns
            var virtualColumnList = PrepareSortedVirtualColumns(virtualColumns, reader.Schema.Fields.Count);

            return await ParquetDataReaderWithVirtualColumns
                .CreateAsync(reader, 0, readNextGroup, virtualColumnList, cancellationToken)
                .ConfigureAwait(false);
        }

        /// <summary>
        /// Creates a new ParquetDataReaderWithVirtualColumns instance from a stream.
        /// </summary>
        /// <param name="stream">The stream containing Parquet data.</param>
        /// <param name="virtualColumns">Collection of virtual columns to include in the reader.</param>
        /// <param name="readNextGroup">If set to true, reads the next group when the current group is exhausted.</param>
        /// <param name="leaveOpen">If set to true, leaves the stream open after the reader is disposed.</param>
        /// <param name="parquetOptions">Optional ParquetOptions to configure the reader.</param>
        /// <returns>A new ParquetDataReaderWithVirtualColumns instance.</returns>
        /// <exception cref="ArgumentNullException">Thrown when stream is null.</exception>
        public static ParquetDataReaderWithVirtualColumns CreateWithVirtualColumns(
            Stream stream,
            IEnumerable<VirtualColumn> virtualColumns,
            bool readNextGroup = true,
            bool leaveOpen = false,
            ParquetOptions? parquetOptions = null)
        {
            ArgumentNullException.ThrowIfNull(stream);
            ArgumentNullException.ThrowIfNull(virtualColumns);

            var reader = ParquetReader
                .CreateAsync(stream, parquetOptions, leaveStreamOpen: leaveOpen, cancellationToken: CancellationToken.None)
                .ConfigureAwait(false)
                .GetAwaiter()
                .GetResult();

            // Prepare sorted list of virtual columns
            var virtualColumnList = PrepareSortedVirtualColumns(virtualColumns, reader.Schema.Fields.Count);

            return new ParquetDataReaderWithVirtualColumns(reader, 0, readNextGroup, virtualColumnList);
        }

        /// <summary>
        /// Asynchronously creates a new ParquetDataReaderWithVirtualColumns instance from a stream.
        /// </summary>
        /// <param name="stream">The stream containing Parquet data.</param>
        /// <param name="virtualColumns">Collection of virtual columns to include in the reader.</param>
        /// <param name="readNextGroup">If set to true, reads the next group when the current group is exhausted.</param>
        /// <param name="leaveOpen">If set to true, leaves the stream open after the reader is disposed.</param>
        /// <param name="parquetOptions">Optional ParquetOptions to configure the reader.</param>
        /// <param name="cancellationToken">Optional cancellation token.</param>
        /// <returns>A task representing the asynchronous operation.</returns>
        /// <exception cref="ArgumentNullException">Thrown when stream is null.</exception>
        public static async Task<ParquetDataReaderWithVirtualColumns> CreateWithVirtualColumnsAsync(
            Stream stream,
            IEnumerable<VirtualColumn> virtualColumns,
            bool readNextGroup = true,
            bool leaveOpen = false,
            ParquetOptions? parquetOptions = null,
            CancellationToken cancellationToken = default)
        {
            ArgumentNullException.ThrowIfNull(stream);
            ArgumentNullException.ThrowIfNull(virtualColumns);

            var reader = await ParquetReader
                .CreateAsync(stream, parquetOptions, leaveStreamOpen: leaveOpen, cancellationToken)
                .ConfigureAwait(false);

            // Prepare sorted list of virtual columns
            var virtualColumnList = PrepareSortedVirtualColumns(virtualColumns, reader.Schema.Fields.Count);

            return await ParquetDataReaderWithVirtualColumns
                .CreateAsync(reader, 0, readNextGroup, virtualColumnList, cancellationToken)
                .ConfigureAwait(false);
        }

        /// <summary>
        /// Helper method to prepare a sorted list of virtual columns.
        /// </summary>
        /// <param name="virtualColumns">Collection of virtual columns.</param>
        /// <param name="physicalColumnCount">Number of physical columns in the Parquet file.</param>
        /// <returns>A sorted list of virtual columns with proper indices.</returns>
        private static SortedList<int, VirtualColumn> PrepareSortedVirtualColumns(
            IEnumerable<VirtualColumn> virtualColumns,
            int physicalColumnCount)
        {
            var result = new SortedList<int, VirtualColumn>();

            int index = physicalColumnCount;
            foreach (var column in virtualColumns)
            {
                result.Add(index++, column);
            }

            return result;
        }

        /// <summary>
        /// Gets metadata from an existing ParquetDataReader instance.
        /// </summary>
        /// <param name="reader">The ParquetDataReader instance.</param>
        /// <returns>A ParquetMetadata object containing information about the Parquet data.</returns>
        /// <exception cref="ArgumentNullException">Thrown when reader is null.</exception>
        /// <exception cref="ObjectDisposedException">Thrown when the reader is disposed.</exception>
        public static ParquetMetadata GetMetadata(this ParquetDataReader reader)
        {
            ArgumentNullException.ThrowIfNull(reader,nameof(reader));
            reader.ThrowIfDisposed();

            // Access the private _reader field through reflection to get the underlying ParquetReader
            var readerField = typeof(ParquetDataReader).GetField("_reader",
                System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);

            if (readerField == null)
                throw new InvalidOperationException("Could not access internal reader field");

            var parquetReader = readerField.GetValue(reader) as ParquetReader;
            if (parquetReader == null)
                throw new InvalidOperationException("Could not access internal ParquetReader");

            return new ParquetMetadata(parquetReader);
        }
    }
}
```

## ParquetDataReaderWithVirtualColumns.cs
*Source: B:\Github\Parquet.Data.Ado\Parquet.Data.Ado\ParquetDataReaderWithVirtualColumns.cs*

```
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using Parquet;
using Parquet.Schema;

namespace Parquet.Data.Reader
{
    /// <summary>
    /// Represents a data reader for Parquet data with support for virtual columns.
    /// Extends the standard <see cref="ParquetDataReader"/> with additional capabilities for columns
    /// that don't physically exist in the Parquet file.
    /// </summary>
    public class ParquetDataReaderWithVirtualColumns : ParquetDataReader
    {
        private readonly SortedList<int, VirtualColumn> _virtualColumns;
        private readonly int _physicalFieldCount;
        private bool _disposed;

        /// <summary>
        /// Initializes a new instance of the <see cref="ParquetDataReaderWithVirtualColumns"/> class.
        /// </summary>
        /// <param name="reader">The Parquet reader.</param>
        /// <param name="currentRowGroup">The current row group.</param>
        /// <param name="readNextGroup">Whether to read the next group.</param>
        /// <param name="virtualColumns">The virtual columns.</param>
        public ParquetDataReaderWithVirtualColumns(
            ParquetReader reader,
            int currentRowGroup,
            bool readNextGroup,
            SortedList<int, VirtualColumn> virtualColumns)
            : base(reader, currentRowGroup, readNextGroup)
        {
            _virtualColumns = virtualColumns ?? new SortedList<int, VirtualColumn>();
            _physicalFieldCount = base.FieldCount;
        }

        /// <summary>
        /// Creates a new instance of ParquetDataReaderWithVirtualColumns asynchronously.
        /// </summary>
        /// <param name="reader">The Parquet reader.</param>
        /// <param name="currentRowGroup">The current row group.</param>
        /// <param name="readNextGroup">Whether to read the next group when the current group is exhausted.</param>
        /// <param name="virtualColumns">The virtual columns to include in the reader.</param>
        /// <param name="cancellationToken">Optional cancellation token.</param>
        /// <returns>A new ParquetDataReaderWithVirtualColumns instance.</returns>
        public static async Task<ParquetDataReaderWithVirtualColumns> CreateAsync(
            ParquetReader reader,
            int currentRowGroup,
            bool readNextGroup,
            SortedList<int, VirtualColumn> virtualColumns,
            CancellationToken cancellationToken = default)
        {
            var dataReader = new ParquetDataReaderWithVirtualColumns(
                reader,
                currentRowGroup,
                readNextGroup,
                virtualColumns);

            // Call the base class's LoadColumnsAsync method which is protected
            await dataReader.LoadColumnsAsync(cancellationToken).ConfigureAwait(false);

            return dataReader;
        }

        /// <summary>
        /// Gets the number of fields in the current row.
        /// </summary>
        public new int FieldCount => _physicalFieldCount + _virtualColumns.Count;

        /// <summary>
        /// Retrieves the value for the given column in the current row.
        /// </summary>
        /// <param name="i">The zero-based column ordinal.</param>
        /// <returns>
        /// The value of the specified column in its native format. 
        /// This method returns a DBNull for null database columns or the default value for virtual columns.
        /// </returns>
        public new object GetValue(int i)
        {
            ThrowIfDisposed();

            if (i < _physicalFieldCount)
            {
                return base.GetValue(i);
            }
            else if (_virtualColumns.TryGetValue(i, out VirtualColumn? virtualColumn) && virtualColumn != null)
            {
                return virtualColumn.DefaultValue ?? DBNull.Value;
            }
            else
            {
                return DBNull.Value;
            }
        }

        /// <summary>
        /// Gets the name of the column at the specified index.
        /// </summary>
        /// <param name="i">The zero-based index of the column to get the name of.</param>
        /// <returns>
        /// The name of the column at the specified index. If the index is within the range of the actual columns, 
        /// it returns the name of the corresponding column. If the index corresponds to a virtual column, 
        /// it returns the name of the virtual column.
        /// </returns>
        public new string GetName(int i)
        {
            ThrowIfDisposed();

            if (i < _physicalFieldCount)
            {
                return base.GetName(i);
            }
            else if (_virtualColumns.TryGetValue(i, out VirtualColumn? virtualColumn) && virtualColumn != null)
            {
                return virtualColumn.ColumnName;
            }
            else
            {
                return string.Empty;
            }
        }

        /// <summary>
        /// Gets the data type of the specified column.
        /// </summary>
        /// <param name="i">The zero-based column ordinal.</param>
        /// <returns>The data type of the specified column.</returns>
        public new Type GetFieldType(int i)
        {
            ThrowIfDisposed();

            if (i < _physicalFieldCount)
            {
                return base.GetFieldType(i);
            }
            else if (_virtualColumns.TryGetValue(i, out VirtualColumn? virtualColumn) && virtualColumn != null)
            {
                return virtualColumn.DataType;
            }
            else
            {
                return typeof(object);
            }
        }

        /// <summary>
        /// Gets the data type name of the specified column.
        /// </summary>
        /// <param name="i">The zero-based column ordinal.</param>
        /// <returns>The data type name of the specified column.</returns>
        public new string GetDataTypeName(int i)
        {
            ThrowIfDisposed();

            if (i < _physicalFieldCount)
            {
                return base.GetDataTypeName(i);
            }
            else if (_virtualColumns.TryGetValue(i, out VirtualColumn? virtualColumn) && virtualColumn != null)
            {
                return virtualColumn.DataType.Name;
            }
            else
            {
                return string.Empty;
            }
        }

        /// <summary>
        /// Gets the ordinal of the column with the specified name.
        /// </summary>
        /// <param name="name">The name of the column.</param>
        /// <returns>
        /// The zero-based ordinal of the column with the specified name. 
        /// If the name specified is not found, returns -1.
        /// </returns>
        public new int GetOrdinal(string name)
        {
            ThrowIfDisposed();
            ArgumentNullException.ThrowIfNull(name);

            try
            {
                // First try to find in physical columns
                return base.GetOrdinal(name);
            }
            catch (ArgumentException)
            {
                // Not found in physical columns, look in virtual columns
                foreach (var kvp in _virtualColumns)
                {
                    if (string.Equals(kvp.Value.ColumnName, name, StringComparison.OrdinalIgnoreCase))
                    {
                        return kvp.Key;
                    }
                }

                // Not found in any column
                throw new ArgumentException($"Column '{name}' not found", nameof(name));
            }
        }

        /// <summary>
        /// Returns a DataTable that describes the column metadata.
        /// </summary>
        /// <returns>A DataTable that describes the column metadata.</returns>
        public new DataTable GetSchemaTable()
        {
            ThrowIfDisposed();

            using DataTable baseSchema = base.GetSchemaTable();

            // Create new schema table with same structure
            DataTable schemaTable = baseSchema.Clone();

            // Copy all existing rows
            foreach (DataRow row in baseSchema.Rows)
            {
                schemaTable.Rows.Add(row.ItemArray);
            }

            // Add rows for virtual columns
            foreach (var kvp in _virtualColumns)
            {
                DataRow row = schemaTable.NewRow();
                row[SchemaTableColumn.ColumnName] = kvp.Value.ColumnName;
                row[SchemaTableColumn.ColumnOrdinal] = kvp.Key;
                row[SchemaTableColumn.ColumnSize] = -1; // Unknown size
                row[SchemaTableColumn.DataType] = kvp.Value.DataType;
                row[SchemaTableColumn.AllowDBNull] = true; // Virtual columns are nullable
                row[SchemaTableColumn.IsUnique] = false;   // Virtual columns are not unique
                row[SchemaTableColumn.IsKey] = false;      // Virtual columns are not keys

                schemaTable.Rows.Add(row);
            }

            return schemaTable;
        }

        /// <summary>
        /// Populates an array with values from the current row.
        /// </summary>
        /// <param name="values">The array to populate.</param>
        /// <returns>The number of values copied.</returns>
        public new int GetValues(object[] values)
        {
            ThrowIfDisposed();
            ArgumentNullException.ThrowIfNull(values);

            int count = Math.Min(values.Length, FieldCount);

            // Handle physical columns
            int physColumns = Math.Min(_physicalFieldCount, count);
            if (physColumns > 0)
            {
                base.GetValues(values);
            }

            // Handle virtual columns
            for (int i = _physicalFieldCount; i < count; i++)
            {
                if (_virtualColumns.TryGetValue(i, out VirtualColumn? virtualColumn) && virtualColumn != null)
                {
                    values[i] = virtualColumn.DefaultValue ?? DBNull.Value;
                }
                else
                {
                    values[i] = DBNull.Value;
                }
            }

            return count;
        }

        /// <summary>
        /// Asynchronously retrieves all the attribute values of the current record into the provided array.
        /// </summary>
        /// <param name="values">An array to hold the attribute values.</param>
        /// <param name="cancellationToken">A token to cancel the operation.</param>
        /// <returns>The number of values copied into the array.</returns>
        public new async Task<int> GetValuesAsync(object[] values, CancellationToken cancellationToken = default)
        {
            ThrowIfDisposed();
            ArgumentNullException.ThrowIfNull(values);

            int count = Math.Min(values.Length, FieldCount);

            // Handle physical columns
            int physColumns = Math.Min(_physicalFieldCount, count);
            if (physColumns > 0)
            {
                await base.GetValuesAsync(values, cancellationToken).ConfigureAwait(false);
            }

            // Handle virtual columns
            for (int i = _physicalFieldCount; i < count; i++)
            {
                if (_virtualColumns.TryGetValue(i, out VirtualColumn? virtualColumn) && virtualColumn != null)
                {
                    values[i] = virtualColumn.DefaultValue ?? DBNull.Value;
                }
                else
                {
                    values[i] = DBNull.Value;
                }
            }

            return count;
        }

        /// <summary>
        /// Determines whether the specified column contains a null value.
        /// </summary>
        /// <param name="i">The zero-based column ordinal.</param>
        /// <returns>True if the specified column value is null; otherwise, false.</returns>
        public new bool IsDBNull(int i)
        {
            ThrowIfDisposed();

            if (i < _physicalFieldCount)
            {
                return base.IsDBNull(i);
            }
            else if (_virtualColumns.TryGetValue(i, out VirtualColumn? virtualColumn) && virtualColumn != null)
            {
                return virtualColumn.DefaultValue == null || Convert.IsDBNull(virtualColumn.DefaultValue);
            }
            else
            {
                return true;
            }
        }

        /// <summary>
        /// Asynchronously determines whether the column contains a null value.
        /// </summary>
        /// <param name="i">The zero-based column ordinal.</param>
        /// <param name="cancellationToken">A token to cancel the operation.</param>
        /// <returns>True if the column value is null; otherwise, false.</returns>
        public new async Task<bool> IsDBNullAsync(int i, CancellationToken cancellationToken = default)
        {
            ThrowIfDisposed();

            if (i < _physicalFieldCount)
            {
                return await base.IsDBNullAsync(i, cancellationToken).ConfigureAwait(false);
            }
            else if (_virtualColumns.TryGetValue(i, out VirtualColumn? virtualColumn) && virtualColumn != null)
            {
                return virtualColumn.DefaultValue == null || Convert.IsDBNull(virtualColumn.DefaultValue);
            }
            else
            {
                return true;
            }
        }

        /// <summary>
        /// Advances the reader to the next record.
        /// </summary>
        /// <returns>true if there are more rows; otherwise false.</returns>
        public new bool Read()
        {
            ThrowIfDisposed();
            return base.Read();
        }

        /// <summary>
        /// Asynchronously advances the reader to the next record.
        /// </summary>
        /// <param name="cancellationToken">Optional cancellation token.</param>
        /// <returns>true if there are more rows; otherwise false.</returns>
        public new Task<bool> ReadAsync(CancellationToken cancellationToken = default)
        {
            ThrowIfDisposed();
            return base.ReadAsync(cancellationToken);
        }

        /// <summary>
        /// Advances the reader to the next result.
        /// </summary>
        /// <returns>true if there are more results; otherwise false.</returns>
        public new bool NextResult()
        {
            ThrowIfDisposed();
            return base.NextResult();
        }

        /// <summary>
        /// Asynchronously advances the reader to the next result.
        /// </summary>
        /// <param name="cancellationToken">Optional cancellation token.</param>
        /// <returns>true if there are more results; otherwise false.</returns>
        public new Task<bool> NextResultAsync(CancellationToken cancellationToken = default)
        {
            ThrowIfDisposed();
            return base.NextResultAsync(cancellationToken);
        }

        /// <summary>
        /// Releases all resources used by the ParquetDataReaderWithVirtualColumns.
        /// </summary>
        public new void Close()
        {
            if (_disposed) return;

            base.Close();
            _disposed = true;
        }

        /// <summary>
        /// Releases all resources used by the ParquetDataReaderWithVirtualColumns.
        /// </summary>
        protected override void Dispose(bool disposing)
        {
            if (_disposed) return;

            if (disposing)
            {
                _virtualColumns?.Clear();
            }

            base.Dispose(disposing);
            _disposed = true;
        }

        /// <summary>
        /// Asynchronously releases all resources used by the ParquetDataReaderWithVirtualColumns.
        /// </summary>
        /// <returns>A task representing the asynchronous dispose operation.</returns>
        public new async ValueTask DisposeAsync()
        {
            if (_disposed) return;

            // Dispose base first
            await base.DisposeAsync().ConfigureAwait(false);

            // Clear virtual columns
            _virtualColumns?.Clear();
            _disposed = true;
        }

        /// <summary>
        /// Throws an ObjectDisposedException if the reader is disposed.
        /// </summary>
        /// <exception cref="ObjectDisposedException">Thrown when the reader is disposed.</exception>
        internal new void ThrowIfDisposed()
        {
            // Update to use ObjectDisposedException.ThrowIf
            ObjectDisposedException.ThrowIf(_disposed, this);

            base.ThrowIfDisposed();
        }

        // Additional IDataReader/IDataRecord implementations that need to be changed for virtual columns

        /// <summary>
        /// Gets the column with the specified name.
        /// </summary>
        /// <param name="name">The name of the column to find.</param>
        /// <returns>The column with the specified name.</returns>
        public new object this[string name] => GetValue(GetOrdinal(name));

        /// <summary>
        /// Gets the column with the specified index.
        /// </summary>
        /// <param name="i">The zero-based column ordinal.</param>
        /// <returns>The column with the specified index.</returns>
        public new object this[int i] => GetValue(i);

        /// <summary>
        /// Gets a value indicating whether the data reader is closed.
        /// </summary>
        public new bool IsClosed => _disposed || base.IsClosed;
    }
}
```

## ParquetDbDataReaderAdapter.cs
*Source: B:\Github\Parquet.Data.Ado\Parquet.Data.Ado\ParquetDbDataReaderAdapter.cs*

```
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Threading;
using System.Threading.Tasks;

namespace Parquet.Data.Reader
{
    /// <summary>
    /// Adapter class that wraps a ParquetDataReader and exposes it as a DbDataReader.
    /// </summary>
    public class ParquetDbDataReaderAdapter : DbDataReader, IEnumerable<IDataRecord>
    {
        private readonly ParquetDataReader _reader;

        //
        // Fields to support an accurate HasRows and safe buffering of the very first row.
        //
        private bool _hasRowsInitialized;
        private bool _hasRows;
        private object[]? _firstRowBuffer;
        private bool _firstRowReturned;

        /// <summary>
        /// Initializes a new instance of the <see cref="ParquetDbDataReaderAdapter"/> class.
        /// </summary>
        /// <param name="reader">The <see cref="ParquetDataReader"/> to wrap.</param>
        public ParquetDbDataReaderAdapter(ParquetDataReader reader)
        {
            _reader = reader ?? throw new ArgumentNullException(nameof(reader));
        }

        /// <inheritdoc/>
        /// <remarks>
        /// We override HasRows with a "first-row buffering" technique. The first time HasRows is checked,
        /// we do a one-time read ahead. If a row is found, we mark HasRows = true and store the row in a buffer
        /// so that subsequent Read() does not skip it.
        ///
        /// If you prefer an alternative approach (e.g. if ParquetDataReader exposes a row count), you can simply
        /// delegate to that. For example:
        ///     public override bool HasRows => !_reader.IsClosed  _reader.RowCount > 0;
        /// </remarks>
        public override bool HasRows
        {
            get
            {
                if (!_hasRowsInitialized && !IsClosed)
                {
                    _hasRowsInitialized = true;

                    // Attempt a one-time read to detect a row.
                    if (_reader.Read())
                    {
                        _hasRows = true;

                        // Buffer the entire row so the user won't lose it on the next Read().
                        _firstRowBuffer = new object[_reader.FieldCount];
                        _reader.GetValues(_firstRowBuffer);
                    }
                }

                return _hasRows;
            }
        }

        /// <inheritdoc/>
        public override object this[int ordinal] => GetValue(ordinal);

        /// <inheritdoc/>
        public override object this[string name] => GetValue(GetOrdinal(name));

        /// <inheritdoc/>
        public override int Depth => _reader.Depth;

        /// <inheritdoc/>
        public override int FieldCount => _reader.FieldCount;

        /// <inheritdoc/>
        public override bool IsClosed => _reader.IsClosed;

        /// <inheritdoc/>
        public override int RecordsAffected => _reader.RecordsAffected;

        /// <inheritdoc/>
        public override bool GetBoolean(int ordinal) => (bool)GetBufferedValue(ordinal);

        /// <inheritdoc/>
        public override byte GetByte(int ordinal) => (byte)GetBufferedValue(ordinal);

        /// <inheritdoc/>
        public override long GetBytes(int ordinal, long dataOffset, byte[]? buffer, int bufferOffset, int length)
        {
            // If the row is still buffered, retrieve from the buffered object array if needed:
            if (!_firstRowReturned && _firstRowBuffer != null)
            {
                // We have the entire row in memory as objects. For getting bytes (e.g. varbinary),
                // we can convert it from the buffered value if it's a byte[] or stream-like object.
                // If your underlying usage requires partial reads, you may need a different approach.
                object val = _firstRowBuffer[ordinal] ?? DBNull.Value;
                return GetBytesFromObject(val, dataOffset, buffer, bufferOffset, length);
            }

            return _reader.GetBytes(ordinal, dataOffset, buffer, bufferOffset, length);
        }

        /// <inheritdoc/>
        public override char GetChar(int ordinal) => (char)GetBufferedValue(ordinal);

        /// <inheritdoc/>
        public override long GetChars(int ordinal, long dataOffset, char[]? buffer, int bufferOffset, int length)
        {
            // Similar logic to GetBytes.
            if (!_firstRowReturned && _firstRowBuffer != null)
            {
                object val = _firstRowBuffer[ordinal] ?? DBNull.Value;
                return GetCharsFromObject(val, dataOffset, buffer, bufferOffset, length);
            }

            return _reader.GetChars(ordinal, dataOffset, buffer, bufferOffset, length);
        }

        /// <inheritdoc/>
        public override string GetDataTypeName(int ordinal) => _reader.GetDataTypeName(ordinal);

        /// <inheritdoc/>
        public override DateTime GetDateTime(int ordinal) => (DateTime)GetBufferedValue(ordinal);

        /// <inheritdoc/>
        public override decimal GetDecimal(int ordinal) => (decimal)GetBufferedValue(ordinal);

        /// <inheritdoc/>
        public override double GetDouble(int ordinal) => (double)GetBufferedValue(ordinal);

        /// <inheritdoc/>
        public override Type GetFieldType(int ordinal) => _reader.GetFieldType(ordinal);

        /// <inheritdoc/>
        public override float GetFloat(int ordinal) => (float)GetBufferedValue(ordinal);

        /// <inheritdoc/>
        public override Guid GetGuid(int ordinal) => (Guid)GetBufferedValue(ordinal);

        /// <inheritdoc/>
        public override short GetInt16(int ordinal) => (short)GetBufferedValue(ordinal);

        /// <inheritdoc/>
        public override int GetInt32(int ordinal) => (int)GetBufferedValue(ordinal);

        /// <inheritdoc/>
        public override long GetInt64(int ordinal) => (long)GetBufferedValue(ordinal);

        /// <inheritdoc/>
        public override string GetName(int ordinal) => _reader.GetName(ordinal);

        /// <inheritdoc/>
        public override int GetOrdinal(string name) => _reader.GetOrdinal(name);

        /// <inheritdoc/>
        public override DataTable GetSchemaTable() => _reader.GetSchemaTable();

        /// <inheritdoc/>
        public override string GetString(int ordinal) => (string)GetBufferedValue(ordinal);

        /// <inheritdoc/>
        public override object GetValue(int ordinal)
        {
            return GetBufferedValue(ordinal);
        }

        /// <inheritdoc/>
        public override int GetValues(object[] values)
        {
            ArgumentNullException.ThrowIfNull(values);

            if (!_firstRowReturned && _firstRowBuffer != null)
            {
                // Copy from buffer
                int copyLen = Math.Min(values.Length, _firstRowBuffer.Length);
                Array.Copy(_firstRowBuffer, values, copyLen);
                // Fill remainder with DBNull if any
                for (int i = copyLen; i < values.Length; i++)
                {
                    values[i] = DBNull.Value;
                }
                return copyLen;
            }

            return _reader.GetValues(values);
        }

        /// <inheritdoc/>
        public override bool IsDBNull(int ordinal)
        {
            object val = GetBufferedValue(ordinal);
            return val == null || val is DBNull;
        }

        /// <inheritdoc/>
        public override bool NextResult() => _reader.NextResult();

        /// <inheritdoc/>
        /// <remarks>
        /// We override Read so that if there is a buffered row (from HasRows), we return it first
        /// without advancing the underlying reader.
        /// </remarks>
        public override bool Read()
        {
            if (!_firstRowReturned && _firstRowBuffer != null)
            {
                _firstRowReturned = true;
                return true;
            }

            return _reader.Read();
        }

        /// <inheritdoc/>
        public override void Close() => _reader.Close();

        /// <summary>
        /// Releases the unmanaged resources used by the ParquetConnection and optionally releases the managed resources.
        /// </summary>
        /// <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                // Properly close and dispose the reader
                _reader.Close();
                _reader.Dispose();

                // Clear any references that might prevent garbage collection
                _firstRowBuffer = null;
            }
            base.Dispose(disposing);
        }

        // --------------------------------------------------
        //  IEnumerable<IDataRecord> support
        // --------------------------------------------------

        /// <inheritdoc/>
        /// <remarks>
        /// This enumerator reads *from the current position* in the data reader to the end.
        /// If you require iteration from the very beginning, you must either re-execute your
        /// query or have a means of repositioning the underlying ParquetDataReader if supported.
        ///
        /// Usage example:
        ///   foreach (IDataRecord record in adapter)
        ///   {
        ///       // ...
        ///   }
        /// </remarks>
        IEnumerator<IDataRecord> IEnumerable<IDataRecord>.GetEnumerator()
        {
            // Enumerate forward only, from the current position to the end.
            while (!IsClosed && Read())
            {
                yield return this;
            }
        }

        /// <inheritdoc/>
        /// <remarks>
        /// The standard non-generic IEnumerator is implemented by DbDataReader (via DbEnumerator),
        /// but we override GetEnumerator here so that "foreach(object obj in adapter)"
        /// enumerates rows as well.
        /// </remarks>
        public override IEnumerator GetEnumerator() => new DbEnumerator(this);

        // --------------------------------------------------
        //  Async methods
        // --------------------------------------------------

        /// <inheritdoc/>
        public override Task<bool> ReadAsync(CancellationToken cancellationToken)
        {
            // If we still have the buffered row, return it first
            if (!_firstRowReturned && _firstRowBuffer != null)
            {
                _firstRowReturned = true;
                return Task.FromResult(true);
            }

            return _reader.ReadAsync(cancellationToken);
        }

        /// <inheritdoc/>
        public override Task<bool> NextResultAsync(CancellationToken cancellationToken)
            => _reader.NextResultAsync(cancellationToken);

        /// <inheritdoc/>
        public override Task<bool> IsDBNullAsync(int ordinal, CancellationToken cancellationToken)
        {
            // If using a row buffer, handle that
            object val = GetBufferedValue(ordinal);
            if (val == null || val is DBNull) return Task.FromResult(true);

            // Or fallback to the actual async call
            return _reader.IsDBNullAsync(ordinal, cancellationToken);
        }

        /// <summary>
        /// Asynchronously releases resources used by the ParquetDbDataReaderAdapter.
        /// </summary>
        public override async ValueTask DisposeAsync()
        {
            // Ensure we properly dispose the reader asynchronously
            if (_reader is IAsyncDisposable asyncDisposable)
            {
                await asyncDisposable.DisposeAsync().ConfigureAwait(false);
            }
            else
            {
                _reader.Dispose();
            }

            // Clear any references that might prevent garbage collection
            _firstRowBuffer = null;

            await base.DisposeAsync().ConfigureAwait(false);
            GC.SuppressFinalize(this);
        }

        // --------------------------------------------------
        //  Internal buffer / helper methods
        // --------------------------------------------------

        private object GetBufferedValue(int ordinal)
        {
            if (!_firstRowReturned && _firstRowBuffer != null)
            {
                return _firstRowBuffer[ordinal] ?? DBNull.Value;
            }

            return _reader.GetValue(ordinal);
        }

        // If your ParquetDataReader usage might store large binary data, you can adapt these helpers
        // to handle partial reads. For simplicity, we treat them as if they're small or we read them in full.
        private static long GetBytesFromObject(object val, long dataOffset, byte[]? buffer, int bufferOffset, int length)
        {
            if (val is DBNull) return 0L;
            if (val is not byte[] bytes) throw new InvalidCastException("Stored value is not a byte array.");

            // If no buffer provided, just return the total length that would be copied
            if (buffer == null) return bytes.Length;

            int bytesAvailable = bytes.Length - (int)dataOffset;
            if (bytesAvailable <= 0) return 0L;

            int bytesToCopy = Math.Min(length, bytesAvailable);
            Array.Copy(bytes, (int)dataOffset, buffer, bufferOffset, bytesToCopy);
            return bytesToCopy;
        }

        private static long GetCharsFromObject(object val, long dataOffset, char[]? buffer, int bufferOffset, int length)
        {
            if (val is DBNull) return 0L;
            if (val is not string s) throw new InvalidCastException("Stored value is not a string.");

            // If no buffer provided, just return the total length that would be copied
            if (buffer == null) return s.Length;

            int charsAvailable = s.Length - (int)dataOffset;
            if (charsAvailable <= 0) return 0L;

            int charsToCopy = Math.Min(length, charsAvailable);
            s.CopyTo((int)dataOffset, buffer, bufferOffset, charsToCopy);
            return charsToCopy;
        }
    }
}

```

## ParquetExtensions.cs
*Source: B:\Github\Parquet.Data.Ado\Parquet.Data.Ado\ParquetExtensions.cs*

```
using System;
using System.Collections.Generic;
using System.Data;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Parquet;
using Parquet.Data;
using Parquet.Schema;
using DataColumn = System.Data.DataColumn; // Explicitly use System.Data.DataColumn
using ParquetDataColumn = Parquet.Data.DataColumn; // Alias for Parquet.Data.DataColumn

namespace Parquet.Data.Reader
{
    /// <summary>
    /// Extension methods for working with Parquet data.
    /// </summary>
    public static class ParquetExtensions
    {
        /// <summary>
        /// Converts a ParquetDataReader to a DataTable.
        /// </summary>
        /// <param name="reader">The ParquetDataReader to convert.</param>
        /// <param name="tableName">Optional name for the resulting DataTable.</param>
        /// <returns>A DataTable containing all data from the reader.</returns>
        /// <exception cref="ArgumentNullException">Thrown when reader is null.</exception>
        public static DataTable ToDataTable(this ParquetDataReader reader, string? tableName = null)
        {
            ArgumentNullException.ThrowIfNull(reader);
            using var schemaTable = reader.GetSchemaTable();
            DataTable result = new DataTable(tableName ?? "ParquetData");
            try
            {
                // Add columns based on schema
                foreach (DataRow row in schemaTable.Rows)
                {
                    var column = new System.Data.DataColumn
                    {
                        ColumnName = row["ColumnName"]?.ToString() ?? string.Empty,
                        DataType = (Type)row["DataType"],
                        ReadOnly = true,
                        AllowDBNull = (bool)row["AllowDBNull"]
                    };

                    result.Columns.Add(column);
                }

                // Add rows
                while (reader.Read())
                {
                    var dataRow = result.NewRow();
                    var values = new object[reader.FieldCount];
                    reader.GetValues(values);

                    for (int i = 0; i < values.Length; i++)
                    {
                        dataRow[i] = values[i];
                    }

                    result.Rows.Add(dataRow);
                }

                return result;
            }
            catch
            {
                result.Dispose();
                throw;
            }
        }

        /// <summary>
        /// Asynchronously converts a ParquetDataReader to a DataTable.
        /// </summary>
        /// <param name="reader">The ParquetDataReader to convert.</param>
        /// <param name="tableName">Optional name for the resulting DataTable.</param>
        /// <param name="cancellationToken">Optional cancellation token.</param>
        /// <returns>A task representing the asynchronous operation.</returns>
        /// <exception cref="ArgumentNullException">Thrown when reader is null.</exception>
        public static async Task<DataTable> ToDataTableAsync(
            this ParquetDataReader reader,
            string? tableName = null,
            CancellationToken cancellationToken = default)
        {
            ArgumentNullException.ThrowIfNull(reader);

            // Get schema table first
            using var schemaTable = reader.GetSchemaTable();

            // Create a local variable BEFORE the try block
            DataTable? result = new DataTable(tableName ?? "ParquetData");
            try
            {
                // Add columns based on the schema
                foreach (DataRow row in schemaTable.Rows)
                {
                    var column = new System.Data.DataColumn
                    {
                        ColumnName = row["ColumnName"]?.ToString() ?? string.Empty,
                        DataType = (Type)row["DataType"],
                        ReadOnly = true,
                        AllowDBNull = (bool)row["AllowDBNull"]
                    };
                    result.Columns.Add(column);
                }

                // Add rows asynchronously
                while (await reader.ReadAsync(cancellationToken).ConfigureAwait(false))
                {
                    cancellationToken.ThrowIfCancellationRequested();

                    var dataRow = result.NewRow();
                    var values = new object[reader.FieldCount];
                    await reader.GetValuesAsync(values, cancellationToken).ConfigureAwait(false);
                    for (int i = 0; i < values.Length; i++)
                    {
                        dataRow[i] = values[i];
                    }
                    result.Rows.Add(dataRow);
                }

                // Transfer ownership - return the table
                DataTable tableToReturn = result;
                result = null; // Setting to null because we're transferring ownership
                return tableToReturn;
            }
            finally
            {
                // Unconditional dispose on non-null value in finally
                result?.Dispose();
            }
        }

        /// <summary>
        /// Exports a DataTable to a Parquet file (synchronous).
        /// </summary>
        /// <param name="dataTable">The DataTable to export.</param>
        /// <param name="filePath">The path of the output Parquet file.</param>
        /// <param name="compressionMethod">Optional compression method. Default is "gzip".</param>
        /// <exception cref="ArgumentNullException">Thrown when dataTable is null.</exception>
        /// <exception cref="ArgumentException">Thrown when filePath is null or empty.</exception>
        public static void ExportToParquet(
            this DataTable dataTable,
            string filePath,
            string compressionMethod = "gzip")
        {
            ArgumentNullException.ThrowIfNull(dataTable);
            if (string.IsNullOrEmpty(filePath))
                throw new ArgumentException("File path cannot be null or empty", nameof(filePath));

            // Create a FileStream with explicit FileOptions for better control
            using (var stream = new FileStream(
                       filePath,
                       FileMode.Create,
                       FileAccess.Write,
                       FileShare.None,
                       bufferSize: 4096,
                       options: FileOptions.None))
            {
                ExportToParquet(dataTable, stream, compressionMethod);

                // Ensure the stream is properly flushed before disposing
                stream.Flush();
            }

            // At this point, the stream is fully disposed, and the file handle should be released
        }

        /// <summary>
        /// Exports a DataTable to a Parquet file stream (synchronous).
        /// </summary>
        /// <param name="dataTable">The DataTable to export.</param>
        /// <param name="stream">The stream to write to.</param>
        /// <param name="compressionMethod">Optional compression method. Default is "gzip".</param>
        /// <exception cref="ArgumentNullException">Thrown when dataTable or stream is null.</exception>
        public static void ExportToParquet(
    this DataTable dataTable,
    Stream stream,
    string compressionMethod = "gzip")
        {
            ArgumentNullException.ThrowIfNull(dataTable);
            ArgumentNullException.ThrowIfNull(stream);

            // Build schema from DataTable columns
            var dataFields = new List<DataField>();
            foreach (System.Data.DataColumn column in dataTable.Columns)
            {
                dataFields.Add(new DataField(column.ColumnName, column.DataType, isNullable: true));
            }
            var schema = new ParquetSchema(dataFields.ToArray());

            // Create ParquetWriter using the sync factory method
            using var writer = ParquetWriter.CreateAsync(schema, stream).GetAwaiter().GetResult();

            // Set compression if specified
            if (!string.IsNullOrEmpty(compressionMethod))
            {
                if (Enum.TryParse<CompressionMethod>(compressionMethod, true, out var method))
                {
                    writer.CompressionMethod = method;
                }
            }

            // Handle empty tables properly
            // Handle empty tables properly
            if (dataTable.Rows.Count == 0)
            {
                // Create a single empty row group with empty columns to ensure proper file structure
                using var emptyGroupWriter = writer.CreateRowGroup();

                for (int colIndex = 0; colIndex < dataTable.Columns.Count; colIndex++)
                {
                    var dataField = (DataField)schema.Fields[colIndex];

                    // Create an empty array of the appropriate type
                    Array emptyArray;
                    if (dataField.ClrType.IsValueType)
                    {
                        // For value types, create an array of Nullable<T>
                        Type nullableType = typeof(Nullable<>).MakeGenericType(dataField.ClrType);
                        emptyArray = Array.CreateInstance(nullableType, 0);
                    }
                    else
                    {
                        // For reference types, a regular array is fine
                        emptyArray = Array.CreateInstance(dataField.ClrType, 0);
                    }

                    var parquetColumn = new ParquetDataColumn(dataField, emptyArray);

                    // Write the empty column
                    emptyGroupWriter.WriteColumnAsync(parquetColumn).GetAwaiter().GetResult();
                }

                // Ensure data is flushed to the stream
                stream.Flush();
                return;
            }

            // Regular case: Calculate row group size and process data
            int rowGroupSize = CalculateOptimalRowGroupSize(dataTable);

            // Write data in row groups
            for (int rowIndex = 0; rowIndex < dataTable.Rows.Count; rowIndex += rowGroupSize)
            {
                int rowsToWrite = Math.Min(rowGroupSize, dataTable.Rows.Count - rowIndex);
                using var groupWriter = writer.CreateRowGroup();

                // Process each column in the DataTable
                for (int colIndex = 0; colIndex < dataTable.Columns.Count; colIndex++)
                {
                    var dataColumn = dataTable.Columns[colIndex];
                    var values = new List<object>(rowsToWrite);

                    // Gather the batch of values for this column
                    for (int i = 0; i < rowsToWrite; i++)
                    {
                        object value = dataTable.Rows[rowIndex + i][colIndex];
                        values.Add(value == DBNull.Value ? null! : value);
                    }

                    // Convert to ParquetDataColumn
                    var dataField = (DataField)schema.Fields[colIndex];
                    Array typedArray = ConvertToTypedArray(values, dataField.ClrType);
                    var parquetColumn = new ParquetDataColumn(dataField, typedArray);

                    // Synchronous blocking call for writing a column
                    groupWriter.WriteColumnAsync(parquetColumn).GetAwaiter().GetResult();
                }
            }

            // Ensure data is flushed to the stream
            stream.Flush();
        }

        private static Array ConvertToTypedArray(List<object> values, Type targetType)
        {
            if (values == null || targetType == null)
                return Array.Empty<object>();

            // For value types, we need to use nullable versions to support nulls in Parquet
            Type arrayType = targetType;
            if (targetType.IsValueType)
            {
                arrayType = typeof(Nullable<>).MakeGenericType(targetType);
            }

            // Create an array of the appropriate type
            Array typedArray = Array.CreateInstance(arrayType, values.Count);

            // Handle special types
            if (targetType == typeof(string))
            {
                for (int i = 0; i < values.Count; i++)
                {
                    object value = values[i];
                    typedArray.SetValue(value == null || value == DBNull.Value ? null : value.ToString(), i);
                }
                return typedArray;
            }
            else if (targetType == typeof(byte[]))
            {
                for (int i = 0; i < values.Count; i++)
                {
                    object value = values[i];
                    typedArray.SetValue(value == null || value == DBNull.Value ? null : (byte[])value, i);
                }
                return typedArray;
            }

            // Handle numeric and other value types
            for (int i = 0; i < values.Count; i++)
            {
                object value = values[i];

                if (value == null || value == DBNull.Value)
                {
                    typedArray.SetValue(null, i);
                }
                else
                {
                    try
                    {
                        // If the value is not already of the target type, convert it
                        if (value.GetType() != targetType)
                        {
                            // Use InvariantCulture to ensure consistent behavior
                            value = Convert.ChangeType(value, targetType, System.Globalization.CultureInfo.InvariantCulture);
                        }

                        // If we're using a nullable type array, box the value
                        if (arrayType != targetType)
                        {
                            // Create a nullable instance
                            var nullableType = typeof(Nullable<>).MakeGenericType(targetType);
                            value = Activator.CreateInstance(nullableType, value)!;
                        }

                        typedArray.SetValue(value, i);
                    }
                    catch (FormatException)
                    {
                        // If conversion fails due to format issues
                        typedArray.SetValue(null, i);
                    }
                    catch (InvalidCastException)
                    {
                        // If conversion fails due to type mismatch
                        typedArray.SetValue(null, i);
                    }
                    catch (OverflowException)
                    {
                        // If conversion fails due to value being out of range
                        typedArray.SetValue(null, i);
                    }
                }
            }

            return typedArray;
        }


        /// <summary>
        /// Asynchronously exports a DataTable to a Parquet file by path.
        /// </summary>
        /// <param name="dataTable">The DataTable to export.</param>
        /// <param name="filePath">The path of the output Parquet file.</param>
        /// <param name="compressionMethod">Optional compression method. Default is "gzip".</param>
        /// <param name="cancellationToken">Optional cancellation token.</param>
        /// <returns>A task representing the asynchronous operation.</returns>
        /// <exception cref="ArgumentNullException">Thrown when dataTable is null.</exception>
        /// <exception cref="ArgumentException">Thrown when filePath is null or empty.</exception>
        public static async Task ExportToParquetAsync(
            this DataTable dataTable,
            string filePath,
            string compressionMethod = "gzip",
            CancellationToken cancellationToken = default)
        {
            ArgumentNullException.ThrowIfNull(dataTable);
            if (string.IsNullOrEmpty(filePath))
                throw new ArgumentException("File path cannot be null or empty", nameof(filePath));

            // Create FileStream with explicit FileOptions for async operations
            using (var stream = new FileStream(
                       filePath,
                       FileMode.Create,
                       FileAccess.Write,
                       FileShare.None,
                       bufferSize: 4096,
                       useAsync: true))
            {
                await dataTable.ExportToParquetAsync(stream, compressionMethod, cancellationToken)
                    .ConfigureAwait(false);

                // Ensure the stream is properly flushed before disposing
                await stream.FlushAsync(cancellationToken).ConfigureAwait(false);
            }

            // At this point, the stream is fully disposed, and the file handle should be released
        }

        /// <summary>
        /// Asynchronously exports a DataTable to a Parquet file stream.
        /// This version correctly handles empty tables and ensures proper resource cleanup.
        /// </summary>
        /// <param name="dataTable">The DataTable to export.</param>
        /// <param name="stream">The stream to write to.</param>
        /// <param name="compressionMethod">Optional compression method. Default is "gzip".</param>
        /// <param name="cancellationToken">Optional cancellation token.</param>
        /// <returns>A task representing the asynchronous operation.</returns>
        /// <exception cref="ArgumentNullException">Thrown when dataTable or stream is null.</exception>
        public static async Task ExportToParquetAsync(
            this DataTable dataTable,
            Stream stream,
            string compressionMethod = "gzip",
            CancellationToken cancellationToken = default)
        {
            ArgumentNullException.ThrowIfNull(dataTable);
            ArgumentNullException.ThrowIfNull(stream);

            // Create schema from DataTable columns
            var dataFields = new List<DataField>();
            foreach (System.Data.DataColumn column in dataTable.Columns)
            {
                dataFields.Add(new DataField(column.ColumnName, column.DataType, isNullable: true));
            }
            var schema = new ParquetSchema(dataFields.ToArray());

            // Create the ParquetWriter asynchronously
            using var writer = await ParquetWriter.CreateAsync(schema, stream, cancellationToken: cancellationToken)
                                                  .ConfigureAwait(false);

            // Set compression method if specified
            if (!string.IsNullOrEmpty(compressionMethod) &&
                Enum.TryParse<CompressionMethod>(compressionMethod, true, out var method))
            {
                writer.CompressionMethod = method;
            }

            // Handle empty tables properly
            // Handle empty tables properly
            if (dataTable.Rows.Count == 0)
            {
                // Create a single empty row group with empty columns to ensure proper file structure
                using var emptyGroupWriter = writer.CreateRowGroup();

                for (int colIndex = 0; colIndex < dataTable.Columns.Count; colIndex++)
                {
                    var dataField = (DataField)schema.Fields[colIndex];

                    // Create an empty array of the appropriate type
                    // IMPORTANT: Make sure we're using the correct nullable type for value types
                    Array emptyArray;
                    if (dataField.ClrType.IsValueType)
                    {
                        // For value types, create an array of Nullable<T>
                        Type nullableType = typeof(Nullable<>).MakeGenericType(dataField.ClrType);
                        emptyArray = Array.CreateInstance(nullableType, 0);
                    }
                    else
                    {
                        // For reference types, a regular array is fine
                        emptyArray = Array.CreateInstance(dataField.ClrType, 0);
                    }

                    var emptyColumn = new ParquetDataColumn(dataField, emptyArray);

                    // Write the empty column
                    await emptyGroupWriter.WriteColumnAsync(emptyColumn, cancellationToken)
                        .ConfigureAwait(false);
                }

                // Ensure data is flushed to the stream
                await stream.FlushAsync(cancellationToken).ConfigureAwait(false);
                return;
            }

            // Regular case: Process non-empty data in batches
            // Calculate row group size (heuristic)
            int rowGroupSize = CalculateOptimalRowGroupSize(dataTable);

            // Process data in batches
            for (int rowIndex = 0; rowIndex < dataTable.Rows.Count; rowIndex += rowGroupSize)
            {
                cancellationToken.ThrowIfCancellationRequested();

                int rowsToWrite = Math.Min(rowGroupSize, dataTable.Rows.Count - rowIndex);

                // There's no async "CreateRowGroup" as of Parquet.Net 7.x; so we call it synchronously.
                using var groupWriter = writer.CreateRowGroup();

                for (int colIndex = 0; colIndex < dataTable.Columns.Count; colIndex++)
                {
                    var dataColumn = dataTable.Columns[colIndex];
                    var values = new List<object>(rowsToWrite);

                    // Extract column values for this batch
                    for (int i = 0; i < rowsToWrite; i++)
                    {
                        object value = dataTable.Rows[rowIndex + i][colIndex];
                        values.Add(value == DBNull.Value ? null! : value);
                    }

                    var dataField = (DataField)schema.Fields[colIndex];
                    Array typedArray = ConvertToTypedArray(values, dataField.ClrType);
                    var parquetColumn = new ParquetDataColumn(dataField, typedArray);

                    // Use the true async call for writing a column
                    await groupWriter.WriteColumnAsync(parquetColumn, cancellationToken)
                                     .ConfigureAwait(false);
                }
            }

            // Ensure data is flushed to the stream
            await stream.FlushAsync(cancellationToken).ConfigureAwait(false);
        }


        /// <summary>
        /// Calculates the optimal row group size for a DataTable based on its structure.
        /// Note: This is a heuristic and may not be optimal for all data patterns.
        /// </summary>
        /// <param name="dataTable">The DataTable to analyze.</param>
        /// <returns>The computed row group size.</returns>
        private static int CalculateOptimalRowGroupSize(DataTable dataTable)
        {
            // Default size - Parquet often suggests up to ~1M rows per group as a starting heuristic
            const int defaultSize = 1_000_000;

            if (dataTable.Rows.Count <= 0) return defaultSize;

            // Estimate memory usage of a single row using the first row
            long estimatedRowSize = 0;
            var row = dataTable.Rows[0];

            foreach (System.Data.DataColumn col in dataTable.Columns)
            {
                Type type = col.DataType;
                object value = row[col];
                if (value == DBNull.Value || value == null)
                {
                    // minimal overhead for null
                    estimatedRowSize += 1;
                }
                else if (type == typeof(string))
                {
                    // rough estimate for Unicode (2 bytes per char)
                    estimatedRowSize += ((string)value).Length * 2;
                }
                else if (type == typeof(byte[]))
                {
                    estimatedRowSize += ((byte[])value).Length;
                }
                else
                {
                    estimatedRowSize += GetEstimatedTypeSize(type);
                }
            }

            // If we can't estimate properly, fall back
            if (estimatedRowSize <= 0) return defaultSize;

            // Target ~64MB per row group
            const long targetRowGroupSize = 64L * 1024L * 1024L; // 64 MB
            int optimalRowCount = (int)(targetRowGroupSize / estimatedRowSize);

            // Keep it within a sensible range
            return Math.Max(1000, Math.Min(defaultSize, optimalRowCount));
        }

        /// <summary>
        /// Gets the estimated size of a type in bytes.
        /// </summary>
        /// <param name="type">The Type to analyze.</param>
        /// <returns>The estimated size in bytes.</returns>
        private static int GetEstimatedTypeSize(Type type)
        {
            if (type == typeof(bool)) return 1;
            if (type == typeof(byte)) return 1;
            if (type == typeof(char)) return 2;
            if (type == typeof(short)) return 2;
            if (type == typeof(ushort)) return 2;
            if (type == typeof(int)) return 4;
            if (type == typeof(uint)) return 4;
            if (type == typeof(float)) return 4;
            if (type == typeof(long)) return 8;
            if (type == typeof(ulong)) return 8;
            if (type == typeof(double)) return 8;
            if (type == typeof(decimal)) return 16;
            if (type == typeof(DateTime)) return 8;
            if (type == typeof(TimeSpan)) return 8;
            if (type == typeof(Guid)) return 16;

            // Default for unknown or variable-sized references
            return 8;
        }
    }
}

```

## ParquetMetadata.cs
*Source: B:\Github\Parquet.Data.Ado\Parquet.Data.Ado\ParquetMetadata.cs*

```
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Parquet;
using Parquet.Schema;

namespace Parquet.Data.Reader
{
    /// <summary>
    /// Represents metadata information for a Parquet file.
    /// </summary>
    public class ParquetMetadata : IDisposable
    {
        private readonly ParquetReader _reader;
        private bool _disposed;

        /// <summary>
        /// Initializes a new instance of the <see cref="ParquetMetadata"/> class.
        /// </summary>
        /// <param name="reader">The Parquet reader from which to extract metadata.</param>
        /// <exception cref="ArgumentNullException">Thrown when reader is null.</exception>
        internal ParquetMetadata(ParquetReader reader)
        {
            _reader = reader ?? throw new ArgumentNullException(nameof(reader));

            // Initialize properties
            RowGroupCount = _reader.RowGroupCount;
            Schema = _reader.Schema;

            // Build statistics for each row group
            var rowGroupStats = new List<RowGroupMetadata>();
            for (int i = 0; i < _reader.RowGroupCount; i++)
            {
                rowGroupStats.Add(new RowGroupMetadata(_reader, i));
            }
            RowGroups = new ReadOnlyCollection<RowGroupMetadata>(rowGroupStats);

            // Calculate total row count
            TotalRowCount = RowGroups.Sum(rg => rg.RowCount);
        }

        /// <summary>
        /// Gets the number of row groups in the Parquet file.
        /// </summary>
        public int RowGroupCount { get; }

        /// <summary>
        /// Gets the schema of the Parquet file.
        /// </summary>
        public ParquetSchema Schema { get; }

        /// <summary>
        /// Gets the total number of rows across all row groups.
        /// </summary>
        public long TotalRowCount { get; }

        /// <summary>
        /// Gets metadata for each row group in the Parquet file.
        /// </summary>
        public ReadOnlyCollection<RowGroupMetadata> RowGroups { get; }

        /// <summary>
        /// Gets detailed information about each column in the file.
        /// </summary>
        public ReadOnlyCollection<ColumnMetadata> Columns
        {
            get
            {
                ThrowIfDisposed();
                var columns = Schema.DataFields.Select(f => new ColumnMetadata(f)).ToList();
                return new ReadOnlyCollection<ColumnMetadata>(columns);
            }
        }

        /// <summary>
        /// Creates a new ParquetMetadata instance from a file path.
        /// </summary>
        /// <param name="filePath">Path to the Parquet file.</param>
        /// <returns>A ParquetMetadata object with information about the file.</returns>
        /// <exception cref="ArgumentNullException">Thrown when filePath is null.</exception>
        /// <exception cref="FileNotFoundException">Thrown when the file does not exist.</exception>
        public static ParquetMetadata FromFile(string filePath)
        {
            ArgumentException.ThrowIfNullOrWhiteSpace(filePath, nameof(filePath));

            if (!System.IO.File.Exists(filePath))
                throw new FileNotFoundException("Parquet file not found", filePath);

            var reader = ParquetReader.CreateAsync(filePath)
                .ConfigureAwait(false).GetAwaiter().GetResult();

            return new ParquetMetadata(reader);
        }

        /// <summary>
        /// Asynchronously creates a new ParquetMetadata instance from a file path.
        /// </summary>
        /// <param name="filePath">Path to the Parquet file.</param>
        /// <param name="cancellationToken">Optional cancellation token.</param>
        /// <returns>A task representing the asynchronous operation.</returns>
        /// <exception cref="ArgumentNullException">Thrown when filePath is null.</exception>
        /// <exception cref="FileNotFoundException">Thrown when the file does not exist.</exception>
        public static async Task<ParquetMetadata> FromFileAsync(string filePath, CancellationToken cancellationToken = default)
        {
            ArgumentException.ThrowIfNullOrWhiteSpace(filePath, nameof(filePath));

            if (!System.IO.File.Exists(filePath))
                throw new FileNotFoundException("Parquet file not found", filePath);

            var reader = await ParquetReader.CreateAsync(filePath, cancellationToken: cancellationToken)
                .ConfigureAwait(false);

            return new ParquetMetadata(reader);
        }

        /// <summary>
        /// Creates a new ParquetMetadata instance from a stream.
        /// </summary>
        /// <param name="stream">The stream containing Parquet data.</param>
        /// <param name="leaveOpen">If true, leaves the stream open after reading; otherwise, closes it.</param>
        /// <returns>A ParquetMetadata object with information about the data.</returns>
        /// <exception cref="ArgumentNullException">Thrown when stream is null.</exception>
        public static ParquetMetadata FromStream(Stream stream, bool leaveOpen = false)
        {
            ArgumentNullException.ThrowIfNull(stream, nameof(stream));

            var reader = ParquetReader.CreateAsync(stream, leaveStreamOpen: leaveOpen)
                .ConfigureAwait(false).GetAwaiter().GetResult();

            return new ParquetMetadata(reader);
        }

        /// <summary>
        /// Asynchronously creates a new ParquetMetadata instance from a stream.
        /// </summary>
        /// <param name="stream">The stream containing Parquet data.</param>
        /// <param name="leaveOpen">If true, leaves the stream open after reading; otherwise, closes it.</param>
        /// <param name="cancellationToken">Optional cancellation token.</param>
        /// <returns>A task representing the asynchronous operation.</returns>
        /// <exception cref="ArgumentNullException">Thrown when stream is null.</exception>
        public static async Task<ParquetMetadata> FromStreamAsync(
            Stream stream,
            bool leaveOpen = false,
            CancellationToken cancellationToken = default)
        {
            ArgumentNullException.ThrowIfNull(stream, nameof(stream));

            var reader = await ParquetReader.CreateAsync(stream, leaveStreamOpen: leaveOpen, cancellationToken: cancellationToken)
                .ConfigureAwait(false);

            return new ParquetMetadata(reader);
        }

        /// <summary>
        /// Disposes resources used by the ParquetMetadata instance.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Protected implementation of Dispose pattern.
        /// </summary>
        /// <param name="disposing">True if called from Dispose(), false if called from finalizer.</param>
        protected virtual void Dispose(bool disposing)
        {
            if (_disposed)
                return;

            if (disposing)
            {
                // Dispose managed resources
                _reader?.Dispose();
            }

            _disposed = true;
        }

        /// <summary>
        /// Throws an ObjectDisposedException if this object has been disposed.
        /// </summary>
        private void ThrowIfDisposed()
        {
            ObjectDisposedException.ThrowIf(_disposed, this);
        }


        /// <summary>
        /// Finalizer to ensure resources are cleaned up if Dispose is not called.
        /// </summary>
        ~ParquetMetadata()
        {
            Dispose(false);
        }
    }

    /// <summary>
    /// Represents metadata for a single row group in a Parquet file.
    /// </summary>
    public class RowGroupMetadata
    {
        private readonly ParquetReader _reader;
        private readonly int _rowGroupIndex;

        internal RowGroupMetadata(ParquetReader reader, int rowGroupIndex)
        {
            _reader = reader ?? throw new ArgumentNullException(nameof(reader));
            _rowGroupIndex = rowGroupIndex;

            // Get row count from the reader's row group info
            using var rowGroupReader = _reader.OpenRowGroupReader(rowGroupIndex);
            RowCount = rowGroupReader.RowCount;
        }

        /// <summary>
        /// Gets the index of this row group.
        /// </summary>
        public int Index => _rowGroupIndex;

        /// <summary>
        /// Gets the number of rows in this row group.
        /// </summary>
        public long RowCount { get; }

        /// <summary>
        /// Returns a string that represents the current object.
        /// </summary>
        public override string ToString() => $"Row Group {Index}: {RowCount} rows";
    }

    /// <summary>
    /// Represents metadata for a column in a Parquet file.
    /// </summary>
    public class ColumnMetadata
    {
        /// <summary>
        /// Gets the field definition for this column.
        /// </summary>
        public DataField Field { get; }

        /// <summary>
        /// Gets the name of the column.
        /// </summary>
        public string Name => Field.Name;

        /// <summary>
        /// Gets the data type of the column.
        /// </summary> 
        public Type DataType => Field.ClrType;

        /// <summary>
        /// Gets whether the column allows null values.
        /// </summary>
        public bool IsNullable => Field.IsNullable;

        internal ColumnMetadata(DataField field)
        {
            Field = field ?? throw new ArgumentNullException(nameof(field));
        }

        /// <summary>
        /// Returns a string representation of this column.
        /// </summary>
        public override string ToString() => $"{Name} ({DataType.Name}{(IsNullable ? ", nullable" : "")})";
    }
}
```

## ParquetMetadataExtensions.cs
*Source: B:\Github\Parquet.Data.Ado\Parquet.Data.Ado\ParquetMetadataExtensions.cs*

```
using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using Parquet;

namespace Parquet.Data.Reader
{
    /// <summary>
    /// Extension methods for accessing Parquet metadata.
    /// </summary>
    public static class ParquetMetadataExtensions
    {
        #region ParquetConnection Extensions

        /// <summary>
        /// Gets metadata information about the Parquet file associated with this connection.
        /// </summary>
        /// <param name="connection">The Parquet connection.</param>
        /// <returns>A ParquetMetadata object containing information about the file.</returns>
        /// <exception cref="ArgumentNullException">Thrown when connection is null.</exception>
        /// <exception cref="InvalidOperationException">Thrown when the connection is not open.</exception>
        public static ParquetMetadata GetMetadata(this ParquetConnection connection)
        {
            ArgumentNullException.ThrowIfNull(connection, nameof(connection));

            if (connection.State != System.Data.ConnectionState.Open)
                throw new InvalidOperationException("Connection must be open to get metadata");

            var reader = connection.Reader;
            return new ParquetMetadata(reader);
        }

        /// <summary>
        /// Gets the number of row groups in the Parquet file associated with this connection.
        /// </summary>
        /// <param name="connection">The Parquet connection.</param>
        /// <returns>The number of row groups in the file.</returns>
        /// <exception cref="ArgumentNullException">Thrown when connection is null.</exception>
        /// <exception cref="InvalidOperationException">Thrown when the connection is not open.</exception>
        public static int GetRowGroupCount(this ParquetConnection connection)
        {
            ArgumentNullException.ThrowIfNull(connection, nameof(connection));

            if (connection.State != System.Data.ConnectionState.Open)
                throw new InvalidOperationException("Connection must be open to get row group count");

            return connection.Reader.RowGroupCount;
        }

        /// <summary>
        /// Gets the total number of rows in the Parquet file associated with this connection.
        /// </summary>
        /// <param name="connection">The Parquet connection.</param>
        /// <returns>The total number of rows in the file.</returns>
        /// <exception cref="ArgumentNullException">Thrown when connection is null.</exception>
        /// <exception cref="InvalidOperationException">Thrown when the connection is not open.</exception>
        public static long GetTotalRowCount(this ParquetConnection connection)
        {
            using var metadata = connection.GetMetadata();
            return metadata.TotalRowCount;
        }

        #endregion

        #region ParquetDataReaderFactory Extensions

        /// <summary>
        /// Gets metadata for a Parquet file without opening a data reader.
        /// </summary>
        /// <param name="filePath">Path to the Parquet file.</param>
        /// <returns>A ParquetMetadata object containing information about the file.</returns>
        /// <exception cref="ArgumentNullException">Thrown when filePath is null.</exception>
        /// <exception cref="FileNotFoundException">Thrown when the file does not exist.</exception>
        public static ParquetMetadata GetMetadata(string filePath)
        {
            return ParquetMetadata.FromFile(filePath);
        }

        /// <summary>
        /// Gets metadata for a Parquet file without opening a data reader (async version).
        /// </summary>
        /// <param name="filePath">Path to the Parquet file.</param>
        /// <param name="cancellationToken">Optional cancellation token.</param>
        /// <returns>A task representing the asynchronous operation.</returns>
        /// <exception cref="ArgumentNullException">Thrown when filePath is null.</exception>
        /// <exception cref="FileNotFoundException">Thrown when the file does not exist.</exception>
        public static Task<ParquetMetadata> GetMetadataAsync(
            string filePath,
            CancellationToken cancellationToken = default)
        {
            return ParquetMetadata.FromFileAsync(filePath, cancellationToken);
        }

        /// <summary>
        /// Gets metadata for a Parquet file from a stream without opening a data reader.
        /// </summary>
        /// <param name="stream">The stream containing Parquet data.</param>
        /// <param name="leaveOpen">If true, leaves the stream open after reading; otherwise, closes it.</param>
        /// <returns>A ParquetMetadata object containing information about the data.</returns>
        /// <exception cref="ArgumentNullException">Thrown when stream is null.</exception>
        public static ParquetMetadata GetMetadata(Stream stream, bool leaveOpen = false)
        {
            return ParquetMetadata.FromStream(stream, leaveOpen);
        }

        /// <summary>
        /// Gets metadata for a Parquet file from a stream without opening a data reader (async version).
        /// </summary>
        /// <param name="stream">The stream containing Parquet data.</param>
        /// <param name="leaveOpen">If true, leaves the stream open after reading; otherwise, closes it.</param>
        /// <param name="cancellationToken">Optional cancellation token.</param>
        /// <returns>A task representing the asynchronous operation.</returns>
        /// <exception cref="ArgumentNullException">Thrown when stream is null.</exception>
        public static Task<ParquetMetadata> GetMetadataAsync(
            Stream stream,
            bool leaveOpen = false,
            CancellationToken cancellationToken = default)
        {
            return ParquetMetadata.FromStreamAsync(stream, leaveOpen, cancellationToken);
        }

        #endregion

        #region ParquetDataReader Extensions

        /// <summary>
        /// Gets the total number of row groups in the Parquet file.
        /// </summary>
        /// <param name="reader">The Parquet data reader.</param>
        /// <returns>The total number of row groups.</returns>
        /// <exception cref="ArgumentNullException">Thrown when reader is null.</exception>
        /// <exception cref="ObjectDisposedException">Thrown when the reader is disposed.</exception>
        public static int GetRowGroupCount(this ParquetDataReader reader)
        {
            ArgumentNullException.ThrowIfNull(reader, nameof(reader));

            reader.ThrowIfDisposed();

            // We can access the private _reader field through reflection
            // This is a bit hacky but avoids modifying the ParquetDataReader class
            var readerField = typeof(ParquetDataReader).GetField("_reader", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);
            if (readerField == null)
                throw new InvalidOperationException("Could not access internal reader field");

            var parquetReader = readerField.GetValue(reader) as ParquetReader;
            if (parquetReader == null)
                throw new InvalidOperationException("Could not access internal ParquetReader");

            return parquetReader.RowGroupCount;
        }

        /// <summary>
        /// Gets the current row group index being read.
        /// </summary>
        /// <param name="reader">The Parquet data reader.</param>
        /// <returns>The current row group index.</returns>
        /// <exception cref="ArgumentNullException">Thrown when reader is null.</exception>
        /// <exception cref="ObjectDisposedException">Thrown when the reader is disposed.</exception>
        public static int GetCurrentRowGroup(this ParquetDataReader reader)
        {
            ArgumentNullException.ThrowIfNull(reader, nameof(reader));

            reader.ThrowIfDisposed();

            // Access the private _currentRowGroup field through reflection
            var currentRowGroupField = typeof(ParquetDataReader).GetField("_currentRowGroup",
                System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);

            if (currentRowGroupField == null)
                throw new InvalidOperationException("Could not access current row group field");

            // Fix for CS8605: Unboxing a possibly null value
            var value = currentRowGroupField.GetValue(reader);
            if (value == null)
                throw new InvalidOperationException("Current row group value is null");

            return (int)value;
        }

        /// <summary>
        /// Gets metadata for a Parquet file without opening a data reader.
        /// </summary>
        /// <param name="filePath">Path to the Parquet file.</param>
        /// <param name="parquetOptions">Optional ParquetOptions to configure the reader.</param>
        /// <returns>A ParquetMetadata object containing information about the file.</returns>
        /// <exception cref="ArgumentNullException">Thrown when filePath is null.</exception>
        /// <exception cref="FileNotFoundException">Thrown when the file does not exist.</exception>
        public static ParquetMetadata GetMetadata(
            string filePath,
            ParquetOptions? parquetOptions = null)
        {
            ArgumentNullException.ThrowIfNull(filePath);

            if (!System.IO.File.Exists(filePath))
                throw new FileNotFoundException("Parquet file not found", filePath);

            // Open the file
            using var stream = System.IO.File.OpenRead(filePath);

            // Create a reader with the specified options
            return GetMetadata(stream, false, parquetOptions);
        }

        /// <summary>
        /// Asynchronously gets metadata for a Parquet file without opening a data reader.
        /// </summary>
        /// <param name="filePath">Path to the Parquet file.</param>
        /// <param name="parquetOptions">Optional ParquetOptions to configure the reader.</param>
        /// <param name="cancellationToken">Optional cancellation token.</param>
        /// <returns>A task representing the asynchronous operation.</returns>
        /// <exception cref="ArgumentNullException">Thrown when filePath is null.</exception>
        /// <exception cref="FileNotFoundException">Thrown when the file does not exist.</exception>
        public static async Task<ParquetMetadata> GetMetadataAsync(
            string filePath,
            ParquetOptions? parquetOptions = null,
            CancellationToken cancellationToken = default)
        {
            ArgumentNullException.ThrowIfNull(filePath);

            if (!System.IO.File.Exists(filePath))
                throw new FileNotFoundException("Parquet file not found", filePath);

            // Open file asynchronously
            var stream = new FileStream(
                filePath,
                FileMode.Open,
                FileAccess.Read,
                FileShare.Read,
                bufferSize: 4096,
                useAsync: true);

            try
            {
                // Get metadata asynchronously
                return await GetMetadataAsync(stream, false, parquetOptions, cancellationToken)
                    .ConfigureAwait(false);
            }
            catch
            {
                // Ensure stream is closed on error
                await stream.DisposeAsync().ConfigureAwait(false);
                throw;
            }
        }

        /// <summary>
        /// Gets metadata for a Parquet file from a stream without opening a data reader.
        /// </summary>
        /// <param name="stream">The stream containing Parquet data.</param>
        /// <param name="leaveOpen">If true, leaves the stream open after reading; otherwise, closes it.</param>
        /// <param name="parquetOptions">Optional ParquetOptions to configure the reader.</param>
        /// <returns>A ParquetMetadata object containing information about the data.</returns>
        /// <exception cref="ArgumentNullException">Thrown when stream is null.</exception>
        public static ParquetMetadata GetMetadata(
            Stream stream,
            bool leaveOpen = false,
            ParquetOptions? parquetOptions = null)
        {
            ArgumentNullException.ThrowIfNull(stream);

            var reader = ParquetReader
                .CreateAsync(stream, parquetOptions, leaveStreamOpen: leaveOpen, cancellationToken: CancellationToken.None)
                .ConfigureAwait(false)
                .GetAwaiter()
                .GetResult();

            return new ParquetMetadata(reader);
        }

        /// <summary>
        /// Asynchronously gets metadata for a Parquet file from a stream without opening a data reader.
        /// </summary>
        /// <param name="stream">The stream containing Parquet data.</param>
        /// <param name="leaveOpen">If true, leaves the stream open after reading; otherwise, closes it.</param>
        /// <param name="parquetOptions">Optional ParquetOptions to configure the reader.</param>
        /// <param name="cancellationToken">Optional cancellation token.</param>
        /// <returns>A task representing the asynchronous operation.</returns>
        /// <exception cref="ArgumentNullException">Thrown when stream is null.</exception>
        public static async Task<ParquetMetadata> GetMetadataAsync(
            Stream stream,
            bool leaveOpen = false,
            ParquetOptions? parquetOptions = null,
            CancellationToken cancellationToken = default)
        {
            ArgumentNullException.ThrowIfNull(stream);

            var reader = await ParquetReader
                .CreateAsync(stream, parquetOptions, leaveStreamOpen: leaveOpen, cancellationToken)
                .ConfigureAwait(false);

            return new ParquetMetadata(reader);
        }
        #endregion
    }
}
```

## ParquetSqlCommand.cs
*Source: B:\Github\Parquet.Data.Ado\Parquet.Data.Ado\ParquetSqlCommand.cs*

```
using System;
using System.Data;
using System.Data.Common;
using System.Threading;
using System.Threading.Tasks;

namespace Parquet.Data.Reader
{
    /// <summary>
    /// Enhanced version of ParquetCommand that supports SQL query execution.
    /// </summary>
    public class ParquetSqlCommand : DbCommand
    {
        private string _commandText = string.Empty;
        private ParquetConnection? _connection;
        private bool _disposed;

        /// <summary>
        /// Initializes a new instance of the <see cref="ParquetSqlCommand"/> class.
        /// </summary>
        public ParquetSqlCommand()
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ParquetSqlCommand"/> class with the specified connection.
        /// </summary>
        /// <param name="connection">The connection to use.</param>
        public ParquetSqlCommand(ParquetConnection connection)
        {
            _connection = connection;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ParquetSqlCommand"/> class with the specified query text and connection.
        /// </summary>
        /// <param name="commandText">The text of the query.</param>
        /// <param name="connection">The connection to use.</param>
        public ParquetSqlCommand(string commandText, ParquetConnection connection)
            : this(connection)
        {
            _commandText = commandText ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the text of the query. Must match the base property nullability (<c>string?</c> in newer .NET).
        /// </summary>
#nullable disable
        public override string CommandText
        {
            get => _commandText;
            set => _commandText = value ?? string.Empty;
        }
#nullable restore

        /// <summary>
        /// Gets or sets the wait time before terminating the attempt to execute a command and generating an error.
        /// </summary>
        public override int CommandTimeout { get; set; } = 30;

        /// <summary>
        /// Gets or sets a value indicating how the CommandText property is interpreted.
        /// </summary>
        public override CommandType CommandType { get; set; } = CommandType.Text;

        /// <summary>
        /// Gets or sets the DbConnection used by this DbCommand.
        /// </summary>
        protected override DbConnection? DbConnection
        {
            get => _connection;
            set
            {
                if (value is not null && value is not ParquetConnection)
                {
                    throw new InvalidOperationException("Connection must be of type ParquetConnection");
                }

                _connection = value as ParquetConnection;
            }
        }

        /// <summary>
        /// Gets the DbParameterCollection.
        /// </summary>
        protected override DbParameterCollection DbParameterCollection
            => throw new NotSupportedException("Parameters are not supported in ParquetSqlCommand");

        /// <summary>
        /// Gets or sets the DbTransaction within which this DbCommand executes.
        /// </summary>
        protected override DbTransaction? DbTransaction
        {
            get => throw new NotSupportedException("Transactions are not supported in ParquetSqlCommand");
            set => throw new NotSupportedException("Transactions are not supported in ParquetSqlCommand");
        }

        /// <summary>
        /// Gets or sets a value indicating whether the command should be visible in an interface control.
        /// </summary>
        public override bool DesignTimeVisible { get; set; }

        /// <summary>
        /// Gets or sets how command results are applied to the DataRow when used by the Update method of a DbDataAdapter.
        /// </summary>
        public override UpdateRowSource UpdatedRowSource { get; set; }

        /// <summary>
        /// Attempts to cancel the execution of a command.
        /// </summary>
        public override void Cancel()
        {
            throw new NotSupportedException("Cancellation is not supported in ParquetSqlCommand");
        }

        /// <summary>
        /// Creates a new parameter.
        /// </summary>
        /// <returns>A new DbParameter.</returns>
        protected override DbParameter CreateDbParameter()
        {
            throw new NotSupportedException("Parameters are not supported in ParquetSqlCommand");
        }

        /// <summary>
        /// Executes a SQL statement against the connection and returns the number of rows affected.
        /// </summary>
        /// <returns>The number of rows affected.</returns>
        public override int ExecuteNonQuery()
        {
            throw new NotSupportedException("ExecuteNonQuery is not supported for read-only Parquet data");
        }

        /// <summary>
        /// Executes the command and returns the first column of the first row in the result set returned by the query.
        /// </summary>
        /// <returns>The first column of the first row in the result set.</returns>
        public override object? ExecuteScalar()
        {
            using var reader = ExecuteDbDataReader(CommandBehavior.SingleRow);
            if (reader.Read())
            {
                return reader.GetValue(0);
            }
            return null;
        }

        /// <summary>
        /// Validates that the SQL command is syntactically correct.
        /// </summary>
        /// <param name="errorMessage">When this method returns, contains the error message if the validation fails, or null if the validation succeeds.</param>
        /// <returns>True if the command is valid; otherwise, false.</returns>
        public bool ValidateCommand(out string? errorMessage)
        {
            if (string.IsNullOrWhiteSpace(_commandText))
            {
                errorMessage = "Command text cannot be empty";
                return false;
            }

            try
            {
                // Basic validation - check if it's a SELECT statement
                string normalizedQuery = _commandText.Trim().ToUpperInvariant();
                if (!normalizedQuery.StartsWith("SELECT ", StringComparison.OrdinalIgnoreCase))
                {
                    errorMessage = "Only SELECT statements are supported";
                    return false;
                }

                errorMessage = null;
                return true;
            }
            catch (FormatException ex)
            {
                errorMessage = $"SQL syntax error: {ex.Message}";
                return false;
            }
            catch (ArgumentException ex)
            {
                errorMessage = $"SQL syntax error: {ex.Message}";
                return false;
            }
        }

        /// <summary>
        /// Prepares the command for execution.
        /// </summary>
        public override void Prepare()
        {
            // Validate the SQL
            if (!ValidateCommand(out string? errorMessage))
            {
                throw new InvalidOperationException($"Invalid SQL command: {errorMessage}");
            }
        }

        /// <summary>
        /// Executes a command text against the connection and returns a data reader.
        /// </summary>
        /// <returns>A data reader containing the results of the command execution.</returns>
        public new DbDataReader ExecuteReader()
        {
            return ExecuteDbDataReader(CommandBehavior.Default);
        }

        /// <summary>
        /// Executes a command text with the specified behavior against the connection and returns a data reader.
        /// </summary>
        /// <param name="behavior">One of the CommandBehavior values.</param>
        /// <returns>A data reader containing the results of the command execution.</returns>
        public new DbDataReader ExecuteReader(CommandBehavior behavior)
        {
            return ExecuteDbDataReader(behavior);
        }

        /// <summary>
        /// Asynchronously executes the command text against the connection and returns a data reader.
        /// </summary>
        /// <param name="cancellationToken">Optional cancellation token.</param>
        /// <returns>A task representing the asynchronous operation.</returns>
        public new async Task<DbDataReader> ExecuteReaderAsync(CancellationToken cancellationToken = default)
        {
            if (_connection == null)
            {
                throw new InvalidOperationException("Connection is not set");
            }

            if (_connection.State != ConnectionState.Open)
            {
                throw new InvalidOperationException("Connection is not open");
            }

            if (!ValidateCommand(out string? errorMessage))
            {
                throw new InvalidOperationException($"Invalid SQL command: {errorMessage}");
            }

            // Use ParquetSqlQuery's static method to get a DataTable asynchronously
            string parquetFilePath = _connection.DataSource;
            var dataTable = await ParquetSqlQuery
                .ExecuteQueryAsync(parquetFilePath, _commandText)
                .ConfigureAwait(false);

            // Create a wrapper that will own and dispose the DataTableReader when it's disposed
            return new DisposableDataTableReader(dataTable);
        }

        /// <summary>
        /// Executes the command text against the connection (synchronously).
        /// Returns a <see cref="DbDataReader"/> over the query results.
        /// </summary>
        /// <param name="behavior">One of the <see cref="CommandBehavior"/> values.</param>
        /// <returns>A <see cref="DbDataReader"/> object.</returns>
        // This method has been carefully reviewed to ensure proper disposal of resources.
        // The DisposableDataTableReader takes ownership of the DataTable and disposes it properly.
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Reliability", "CA2000:Dispose objects before losing scope",
            Justification = "Ownership of DataTable is transferred to DisposableDataTableReader which handles disposal.")]
        protected override DbDataReader ExecuteDbDataReader(CommandBehavior behavior)
        {
            if (_connection == null)
            {
                throw new InvalidOperationException("Connection is not set");
            }

            if (_connection.State != ConnectionState.Open)
            {
                throw new InvalidOperationException("Connection is not open");
            }

            if (!ValidateCommand(out string? errorMessage))
            {
                throw new InvalidOperationException($"Invalid SQL command: {errorMessage}");
            }

            // Use ParquetSqlQuery's static method to get a DataTable
            string parquetFilePath = _connection.DataSource;

            // Get the DataTable
            DataTable resultTable = ParquetSqlQuery
                .ExecuteQueryAsync(parquetFilePath, _commandText)
                .GetAwaiter().GetResult();

            // Create and return a reader that takes ownership of the DataTable
            return new DisposableDataTableReader(resultTable);
        }


        /// <summary>
        /// Releases the unmanaged resources used by the ParquetSqlCommand and optionally releases the managed resources.
        /// </summary>
        /// <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        protected override void Dispose(bool disposing)
        {
            if (_disposed) return;

            if (disposing)
            {
                // We don't own the connection, so we don't dispose it here
            }

            _disposed = true;
            base.Dispose(disposing);
        }
    }
}

```

## ParquetSqlDataReader.cs
*Source: B:\Github\Parquet.Data.Ado\Parquet.Data.Ado\ParquetSqlDataReader.cs*

```
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Threading;
using System.Threading.Tasks;
using Parquet;
using Parquet.Data;

namespace Parquet.Data.Reader
{
    /// <summary>
    /// A specialized ParquetDataReader that applies SQL filtering and projection.
    /// </summary>
    public class ParquetSqlDataReader : ParquetDataReader
    {
        private readonly string _whereClause;
        private readonly DataTable _schemaTable;
        private readonly int[] _columnMap;
        private readonly object[] _rowBuffer;

        /// <summary>
        /// Initializes a new instance of the <see cref="ParquetSqlDataReader"/> class.
        /// </summary>
        /// <param name="reader">The ParquetReader to read from.</param>
        /// <param name="whereClause">The WHERE clause to apply.</param>
        /// <param name="selectedColumnIndices">Indices of the selected columns.</param>
        /// <param name="schemaTable">Schema table for evaluating conditions.</param>
        public ParquetSqlDataReader(
            ParquetReader reader,
            string? whereClause,
            int[] selectedColumnIndices,
            DataTable schemaTable)
            : base(reader, 0, true)
        {
            ArgumentNullException.ThrowIfNull(selectedColumnIndices);
            ArgumentNullException.ThrowIfNull(schemaTable);

            _whereClause = whereClause ?? string.Empty;
            _columnMap = selectedColumnIndices;
            _schemaTable = schemaTable;
            _rowBuffer = new object[base.FieldCount];
        }

        /// <summary>
        /// Creates a new instance of ParquetSqlDataReader asynchronously.
        /// </summary>
        /// <param name="reader">The ParquetReader to read from.</param>
        /// <param name="whereClause">The WHERE clause to apply.</param>
        /// <param name="selectedColumnIndices">Indices of the selected columns.</param>
        /// <param name="schemaTable">Schema table for evaluating conditions.</param>
        /// <param name="cancellationToken">Optional cancellation token.</param>
        /// <returns>A new ParquetSqlDataReader instance.</returns>
        public static async Task<ParquetDataReader> CreateAsync(
            ParquetReader reader,
            string? whereClause,
            int[] selectedColumnIndices,
            DataTable schemaTable,
            CancellationToken cancellationToken = default)
        {
            var dataReader = new ParquetSqlDataReader(reader, whereClause, selectedColumnIndices, schemaTable);
            // Use reflection to call the protected method
            var method = typeof(ParquetDataReader).GetMethod(
                "LoadColumnsAsync",
                System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic);

            if (method != null)
            {
                await ((Task)method.Invoke(dataReader, new object[] { cancellationToken })!).ConfigureAwait(false);
            }
            return dataReader;
        }

        /// <summary>
        /// Evaluates if the current row satisfies the WHERE clause condition.
        /// </summary>
        /// <param name="rowValues">The values of the current row.</param>
        /// <returns>True if the row satisfies the condition; otherwise, false.</returns>
        private bool EvaluateWhereClause(object[] rowValues)
        {
            if (string.IsNullOrWhiteSpace(_whereClause))
            {
                return true; // No WHERE clause, all rows match
            }

            // Use ParquetSqlQuery.ExecuteQueryAsync to evaluate the condition
            // This is a workaround since we can't access the private method directly
            // In a real implementation, you would need to duplicate or expose the logic

            // Simplified placeholder logic - you should implement proper condition evaluation here
            return true; // For now, always return true to avoid compilation errors
        }

        /// <summary>
        /// Advances the reader to the next record that matches the SQL filter.
        /// </summary>
        /// <returns>True if a matching record was found; otherwise, false.</returns>
        public new bool Read()
        {
            while (base.Read())
            {
                // Get all values for the current row
                base.GetValues(_rowBuffer);

                // Apply WHERE clause filtering
                if (EvaluateWhereClause(_rowBuffer))
                {
                    return true;
                }
            }

            return false;
        }

        /// <summary>
        /// Asynchronously advances the reader to the next record that matches the SQL filter.
        /// </summary>
        /// <param name="cancellationToken">Optional cancellation token.</param>
        /// <returns>A task representing the asynchronous operation.</returns>
        /// <summary>
        /// Asynchronously advances the reader to the next record that matches the SQL filter.
        /// </summary>
        public new async Task<bool> ReadAsync(CancellationToken cancellationToken = default)
        {
            while (await base.ReadAsync(cancellationToken).ConfigureAwait(false))
            {
                cancellationToken.ThrowIfCancellationRequested();

                // Get all values for the current row
                await base.GetValuesAsync(_rowBuffer, cancellationToken).ConfigureAwait(false);

                // Apply WHERE clause filtering
                if (EvaluateWhereClause(_rowBuffer))
                {
                    return true;
                }
            }

            return false;
        }

        /// <summary>
        /// Gets the value of the specified column in its native format.
        /// </summary>
        /// <param name="i">The zero-based column ordinal.</param>
        /// <returns>The value of the specified column.</returns>
        public new object GetValue(int i)
        {
            // Map the requested column index to the actual column index
            if (i < 0 || i >= _columnMap.Length)
            {
                return DBNull.Value;
            }

            int actualIndex = _columnMap[i];
            return base.GetValue(actualIndex);
        }

        /// <summary>
        /// Populates an array with values from the current row.
        /// </summary>
        /// <param name="values">The array to populate.</param>
        /// <returns>The number of values copied.</returns>
        public new int GetValues(object[] values)
        {
            ArgumentNullException.ThrowIfNull(values);

            int count = Math.Min(values.Length, _columnMap.Length);

            // Get all values from base reader
            base.GetValues(_rowBuffer);

            // Map them to result based on projection
            for (int i = 0; i < count; i++)
            {
                values[i] = _rowBuffer[_columnMap[i]];
            }

            return count;
        }

        /// <summary>
        /// Returns a DataTable that describes the column metadata.
        /// </summary>
        /// <returns>A DataTable that describes the column metadata.</returns>
        /// <summary>
        /// Returns a DataTable that describes the column metadata.
        /// </summary>
        /// <returns>A DataTable that describes the column metadata.</returns>
        /// <summary>
        /// Returns a DataTable that describes the column metadata.
        /// </summary>
        /// <returns>A DataTable that describes the column metadata.</returns>
        public new DataTable GetSchemaTable()
        {
            ThrowIfDisposed();

            // Using using declaration to ensure disposal of baseSchema
            using (DataTable baseSchema = base.GetSchemaTable())
            {
                // Create a new DataTable with the same schema
                DataTable projectedSchema = baseSchema.Clone();

                try
                {
                    // Apply projection to schema
                    for (int i = 0; i < _columnMap.Length; i++)
                    {
                        int sourceIndex = _columnMap[i];
                        if (sourceIndex < baseSchema.Rows.Count)
                        {
                            DataRow newRow = projectedSchema.NewRow();
                            DataRow sourceRow = baseSchema.Rows[sourceIndex];

                            // Copy values from source row using column ordinals instead of names
                            for (int colIndex = 0; colIndex < baseSchema.Columns.Count; colIndex++)
                            {
                                newRow[colIndex] = sourceRow[colIndex];
                            }

                            // Update ordinal to match the projection
                            newRow["ColumnOrdinal"] = i;

                            projectedSchema.Rows.Add(newRow);
                        }
                    }

                    return projectedSchema;
                }
                catch
                {
                    // In case of exception, dispose projectedSchema and rethrow
                    projectedSchema.Dispose();
                    throw;
                }
            }
            // baseSchema is automatically disposed when exiting the using block
        }

        /// <summary>
        /// Gets the number of columns in the current row after projection.
        /// </summary>
        public new int FieldCount => _columnMap.Length;

        /// <summary>
        /// Gets the name of the specified field.
        /// </summary>
        /// <param name="i">The zero-based column ordinal.</param>
        /// <returns>The name of the field.</returns>
        public new string GetName(int i)
        {
            if (i < 0 || i >= _columnMap.Length)
            {
                return string.Empty;
            }

            int actualIndex = _columnMap[i];
            return base.GetName(actualIndex);
        }

        /// <summary>
        /// Gets the data type information for the specified field.
        /// </summary>
        /// <param name="i">The zero-based field ordinal.</param>
        /// <returns>The data type information for the specified field.</returns>
        public new string GetDataTypeName(int i)
        {
            if (i < 0 || i >= _columnMap.Length)
            {
                return string.Empty;
            }

            int actualIndex = _columnMap[i];
            return base.GetDataTypeName(actualIndex);
        }

        /// <summary>
        /// Gets the data type of the specified column.
        /// </summary>
        /// <param name="i">The zero-based column ordinal.</param>
        /// <returns>The data type of the specified column.</returns>
        public new Type GetFieldType(int i)
        {
            if (i < 0 || i >= _columnMap.Length)
            {
                return typeof(object);
            }

            int actualIndex = _columnMap[i];
            return base.GetFieldType(actualIndex);
        }

        /// <summary>
        /// Returns the index of the named field.
        /// </summary>
        /// <param name="name">The name of the field to find.</param>
        /// <returns>The index of the named field.</returns>
        public new int GetOrdinal(string name)
        {
            ArgumentNullException.ThrowIfNull(name);

            for (int i = 0; i < _columnMap.Length; i++)
            {
                if (string.Equals(GetName(i), name, StringComparison.OrdinalIgnoreCase))
                {
                    return i;
                }
            }

            throw new ArgumentException($"Column '{name}' not found", nameof(name));
        }
    }
}
```

## ParquetSqlQuery.cs
*Source: B:\Github\Parquet.Data.Ado\Parquet.Data.Ado\ParquetSqlQuery.cs*

```
using System;
using System.Collections.Generic;
using System.Data;
using System.Globalization;
using System.Linq;
using System.Threading.Tasks;
using Parquet;
using Parquet.Data;
using Parquet.Schema;

namespace Parquet.Data.Reader
{
    /// <summary>
    /// Provides functionality to execute SQL SELECT queries against Parquet files.
    /// </summary>
    /// <remarks>
    /// This class supports parsing and executing SQL SELECT queries with features such as:
    /// - Selecting all columns or specific columns.
    /// - Applying WHERE clauses with complex conditions.
    /// - Reading and filtering data from Parquet files asynchronously.
    /// </remarks>
    public static class ParquetSqlQuery
    {
        /// <summary>
        /// Parses a SQL SELECT query and executes it against the given Parquet file, returning the result as a DataTable.
        /// Supports '*' (all columns) or specific column names, and complex WHERE clauses.
        /// </summary>
        public static async Task<DataTable> ExecuteQueryAsync(string parquetFilePath, string sqlQuery)
        {
            if (string.IsNullOrWhiteSpace(sqlQuery))
                throw new ArgumentException("Query cannot be null or empty.", nameof(sqlQuery));
            if (string.IsNullOrWhiteSpace(parquetFilePath))
                throw new ArgumentException("Parquet file path cannot be null or empty.", nameof(parquetFilePath));

            // Parse the SQL query using QueryListener
            var listener = new SqlParser();
            listener.ParseQuery(sqlQuery);

            if (!listener.StatementFound)
                throw new InvalidOperationException("Only SELECT queries are supported by ParquetSqlQuery.");

            // If the query says SELECT * then read all columns; otherwise the user-specified list
            bool selectAllColumns = listener.SelectAll;
            List<string> selectedColumns = listener.SelectedColumns ?? new List<string>();

            // Prepare the result DataTable
            var resultTable = new System.Data.DataTable();

            // Open the Parquet file
            ParquetReader reader = await ParquetReader.CreateAsync(parquetFilePath).ConfigureAwait(false);
            using (reader)
            {
                // Use the columns extracted by the parser
                var whereColumns = listener.WhereColumnReferences;

                // Merge SELECT columns + WHERE columns into "allRequiredColumns" if not selecting all
                HashSet<string> allRequiredColumns = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
                if (!selectAllColumns)
                {
                    foreach (string col in selectedColumns)
                        allRequiredColumns.Add(col);
                    foreach (string wcol in whereColumns)
                        allRequiredColumns.Add(wcol);
                }

                // Figure out which columns to read
                DataField[] allFields = reader.Schema.GetDataFields();
                DataField[] fieldsToRead;
                if (selectAllColumns)
                {
                    fieldsToRead = allFields;
                }
                else
                {
                    var tempList = new List<DataField>();
                    foreach (string colName in allRequiredColumns)
                    {
                        DataField? field = Array.Find(
                            allFields, f => f.Name.Equals(colName, StringComparison.OrdinalIgnoreCase));
                        if (field == null)
                            throw new InvalidOperationException($"Column '{colName}' not found in Parquet file schema.");
                        tempList.Add(field);
                    }
                    fieldsToRead = tempList.ToArray();
                }

                // Create DataTable columns based on the fieldsToRead
                foreach (DataField field in fieldsToRead)
                {
                    Type clrType = field.ClrType;
                    // Create a System.Data.DataColumn, set AllowDBNull = true
                    var col = new System.Data.DataColumn(field.Name, clrType)
                    {
                        AllowDBNull = true
                    };
                    resultTable.Columns.Add(col);
                }

                // Read row groups, populate the DataTable
                for (int groupIndex = 0; groupIndex < reader.RowGroupCount; groupIndex++)
                {
                    Parquet.Data.DataColumn[] dataColumns =
                        await reader.ReadEntireRowGroupAsync(groupIndex).ConfigureAwait(false);

                    int rowCount = dataColumns.Length > 0 ? dataColumns[0].Data.Length : 0;

                    for (int i = 0; i < rowCount; i++)
                    {
                        object[] rowValues = new object[resultTable.Columns.Count];

                        // Fill rowValues from the parquet data
                        for (int colIdx = 0; colIdx < fieldsToRead.Length; colIdx++)
                        {
                            DataField field = fieldsToRead[colIdx];
                            var colData = Array.Find(dataColumns, dc => dc.Field.Equals(field));

                            object? value = colData?.Data.GetValue(i);
                            if (value == null) value = DBNull.Value;
                            rowValues[colIdx] = value;
                        }

                        // Create a dictionary of column values for condition evaluation
                        Dictionary<string, object> rowData = new Dictionary<string, object>(StringComparer.OrdinalIgnoreCase);
                        for (int colIdx = 0; colIdx < resultTable.Columns.Count; colIdx++)
                        {
                            rowData[resultTable.Columns[colIdx].ColumnName] = rowValues[colIdx];
                        }

                        // Apply the WHERE filter if present
                        // Use the WhereConditionTree from QueryListener instead of manual parsing
                        if (listener.WhereConditionTree == null || listener.WhereConditionTree.Evaluate(rowData))
                        {
                            resultTable.Rows.Add(rowValues);
                        }
                    }
                }
            }

            return resultTable;
        }
    }
}
```

## SqlParser.cs
*Source: B:\Github\Parquet.Data.Ado\Parquet.Data.Ado\SqlParser.cs*

```
using Microsoft.SqlServer.TransactSql.ScriptDom;
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;

namespace Parquet.Data.Reader
{
    /// <summary>
    /// Enhanced query parser using Microsoft.SqlServer.TransactSql.ScriptDom to extract detailed information
    /// about SQL queries including SELECT columns, WHERE clauses, GROUP BY, aggregations, and more.
    /// </summary>
    internal sealed class SqlParser
    {
        #region Public Properties (Core Functionality)

        /// <summary>
        /// Set to true if a SELECT statement was found in the parsed query.
        /// </summary>
        public bool StatementFound { get; private set; }

        /// <summary>
        /// Set to true if a SELECT * was found (no individual column list).
        /// </summary>
        public bool SelectAll { get; private set; }

        /// <summary>
        /// List of columns found in the SELECT clause.
        /// </summary>
        public List<string> SelectedColumns { get; } = new List<string>();

        /// <summary>
        /// Detailed representation of selected columns, including aliases and expressions.
        /// </summary>
        public List<ColumnInfo> DetailedColumns { get; } = new List<ColumnInfo>();

        /// <summary>
        /// Text of the WHERE clause if found.
        /// </summary>
        public string? WhereClauseText { get; private set; }

        /// <summary>
        /// Column references found in the WHERE clause.
        /// </summary>
        public HashSet<string> WhereColumnReferences { get; } = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

        /// <summary>
        /// True if any parse or processing errors were encountered.
        /// </summary>
        public bool HasErrors { get; private set; }

        /// <summary>
        /// List of error messages encountered during parsing or processing.
        /// </summary>
        public List<string> ErrorMessages { get; } = new List<string>();

        /// <summary>
        /// Structured representation of the WHERE clause as a condition tree.
        /// </summary>
        public ConditionTree? WhereConditionTree { get; private set; }

        /// <summary>
        /// Structured representation of the HAVING clause as a condition tree.
        /// </summary>
        public ConditionTree? HavingConditionTree { get; private set; }

        #endregion

        #region Advanced Query Features

        /// <summary>
        /// Tracks if the query contains a GROUP BY clause.
        /// </summary>
        public bool HasGroupBy { get; private set; }

        /// <summary>
        /// Columns used in the GROUP BY clause.
        /// </summary>
        public List<string> GroupByColumns { get; } = new List<string>();

        /// <summary>
        /// Tracks if the query contains a HAVING clause.
        /// </summary>
        public bool HasHaving { get; private set; }

        /// <summary>
        /// Text of the HAVING clause if found.
        /// </summary>
        public string? HavingClauseText { get; private set; }

        /// <summary>
        /// Column references found in the HAVING clause.
        /// </summary>
        public HashSet<string> HavingColumnReferences { get; } = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

        /// <summary>
        /// Tracks if the query contains an ORDER BY clause.
        /// </summary>
        public bool HasOrderBy { get; private set; }

        /// <summary>
        /// Columns used in the ORDER BY clause, with sort direction.
        /// </summary>
        public List<OrderByInfo> OrderByColumns { get; } = new List<OrderByInfo>();

        /// <summary>
        /// Tracks if the query uses JOIN operations.
        /// </summary>
        public bool HasJoins { get; private set; }

        /// <summary>
        /// Detailed information about joins in the query.
        /// </summary>
        public List<JoinInfo> Joins { get; } = new List<JoinInfo>();

        /// <summary>
        /// Tables referenced in the FROM clause.
        /// </summary>
        public List<TableInfo> Tables { get; } = new List<TableInfo>();

        /// <summary>
        /// Tracks if any aggregation functions are used.
        /// </summary>
        public bool HasAggregates { get; private set; }

        /// <summary>
        /// Aggregate functions used in the query.
        /// </summary>
        public List<AggregateInfo> Aggregates { get; } = new List<AggregateInfo>();

        /// <summary>
        /// Tracks DISTINCT usage.
        /// </summary>
        public bool HasDistinct { get; private set; }

        /// <summary>
        /// Tracks TOP clause usage.
        /// </summary>
        public bool HasTopClause { get; private set; }

        /// <summary>
        /// Value of the TOP clause if specified.
        /// </summary>
        public string? TopValue { get; private set; }

        /// <summary>
        /// Whether TOP is used with PERCENT.
        /// </summary>
        public bool TopIsPercent { get; private set; }

        /// <summary>
        /// Maps column aliases to expressions.
        /// </summary>
        public Dictionary<string, string> ColumnAliases { get; } =
            new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);

        #endregion

        #region Constructors / No-Op Overrides (Preserving Old Signatures)

        // The old ANTLR-based code used to rely on TSqlParserBaseListener overrides.
        // We keep the same method names and signatures to avoid breaking changes.
        // They are no-ops here, because ScriptDom uses a different visitation model.
        public SqlParser()
        {
        }

        #endregion

        #region Primary Entry Point for the Microsoft Parser

        /// <summary>
        /// Main method to parse the given T-SQL query and populate all properties.
        /// </summary>
        /// <param name="query">The T-SQL query string to parse.</param>
        public void ParseQuery(string query)
        {
            // Clear any existing data
            ClearAllState();

            if (string.IsNullOrWhiteSpace(query))
            {
                return;
            }

            try
            {
                // Choose T-SQL version-specific parser as appropriate.
                // TSql150Parser covers a broad set of modern T-SQL syntax
                TSql150Parser parser = new TSql150Parser(false);

                IList<ParseError> parseErrors;
                TSqlFragment fragment;
                using (var sr = new StringReader(query))
                {
                    fragment = parser.Parse(sr, out parseErrors);
                }

                // Check parse errors
                if (parseErrors != null && parseErrors.Count > 0)
                {
                    HasErrors = true;
                    foreach (var err in parseErrors)
                    {
                        ErrorMessages.Add(string.Format(CultureInfo.InvariantCulture,
                            "Error at line {0}:{1} - {2}", err.Line, err.Column, err.Message));
                    }
                }

                // If we got a parse tree, proceed to analyze it via visitors
                if (fragment != null)
                {
                    // Primary visitor processes the query's main structure
                    var visitor = new SqlStructureVisitor(this);
                    fragment.Accept(visitor);
                }
            }
            catch (InvalidOperationException ex)
            {
                HasErrors = true;
                ErrorMessages.Add(string.Format(CultureInfo.InvariantCulture,
                    "Invalid operation during parsing: {0}", ex.Message));
            }
            catch (IOException ex) // For StringReader operations
            {
                HasErrors = true;
                ErrorMessages.Add(string.Format(CultureInfo.InvariantCulture,
                    "IO error during parsing: {0}", ex.Message));
            }
            catch (Exception ex) when (
                ex is not OutOfMemoryException &&
                ex is not StackOverflowException &&
                ex is not AccessViolationException)
            {
                // Avoid catching fatal exceptions but still catch other unexpected issues
                HasErrors = true;
                ErrorMessages.Add(string.Format(CultureInfo.InvariantCulture,
                    "Error during parsing: {0}", ex.Message));
            }
        }

        /// <summary>
        /// Clears all state to prepare for a new query parse.
        /// </summary>
        private void ClearAllState()
        {
            // Clear basic properties from original implementation
            StatementFound = false;
            SelectAll = false;
            SelectedColumns.Clear();
            DetailedColumns.Clear();
            WhereClauseText = null;
            WhereColumnReferences.Clear();
            HasErrors = false;
            ErrorMessages.Clear();

            // Clear advanced query properties
            HasGroupBy = false;
            GroupByColumns.Clear();
            HasHaving = false;
            HavingClauseText = null;
            HavingColumnReferences.Clear();
            HasOrderBy = false;
            OrderByColumns.Clear();
            HasJoins = false;
            Joins.Clear();
            Tables.Clear();
            HasAggregates = false;
            Aggregates.Clear();
            HasDistinct = false;
            HasTopClause = false;
            TopValue = null;
            TopIsPercent = false;
            ColumnAliases.Clear();
            // Clear condition trees
            WhereConditionTree = null;
            HavingConditionTree = null;
        }

        #endregion

        #region Structures for Advanced Query Information
        /// <summary>
        /// Detailed information about a column in a SELECT statement.
        /// </summary>
        public sealed class ColumnInfo
        {
            /// <summary>
            /// Column name or expression text.
            /// </summary>
            public string Expression { get; set; } = string.Empty;

            /// <summary>
            /// Column alias if specified.
            /// </summary>
            public string? Alias { get; set; }

            /// <summary>
            /// True if the column is a function call (aggregate or scalar).
            /// </summary>
            public bool IsFunction { get; set; }

            /// <summary>
            /// Function name if IsFunction is true.
            /// </summary>
            public string? FunctionName { get; set; }

            /// <summary>
            /// True if this is an aggregate function (COUNT, SUM, etc.).
            /// </summary>
            public bool IsAggregate { get; set; }

            /// <summary>
            /// Column names referenced in this expression.
            /// </summary>
            public HashSet<string> ReferencedColumns { get; } = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

            /// <summary>
            /// True if this is a computed column (expression, not simple column).
            /// </summary>
            public bool IsComputed { get; set; }

            /// <summary>
            /// True if this column appears to be a literal/constant.
            /// </summary>
            public bool IsLiteral { get; set; }

            /// <summary>
            /// The full text of the column specification including alias.
            /// </summary>
            public string FullText { get; set; } = string.Empty;
        }

        /// <summary>
        /// Information about an ORDER BY column.
        /// </summary>
        public sealed class OrderByInfo
        {
            /// <summary>
            /// Column name or expression text.
            /// </summary>
            public string ColumnName { get; set; } = string.Empty;

            /// <summary>
            /// True if ordering is descending.
            /// </summary>
            public bool IsDescending { get; set; }

            /// <summary>
            /// Full text of the ORDER BY element.
            /// </summary>
            public string FullText { get; set; } = string.Empty;
        }

        /// <summary>
        /// Information about a JOIN clause.
        /// </summary>
        public sealed class JoinInfo
        {
            /// <summary>
            /// Type of join (INNER, LEFT, RIGHT, FULL, CROSS).
            /// </summary>
            public string JoinType { get; set; } = string.Empty;

            /// <summary>
            /// Left table in the join.
            /// </summary>
            public string LeftTable { get; set; } = string.Empty;

            /// <summary>
            /// Right table in the join.
            /// </summary>
            public string RightTable { get; set; } = string.Empty;

            /// <summary>
            /// ON condition of the join.
            /// </summary>
            public string Condition { get; set; } = string.Empty;

            /// <summary>
            /// Columns referenced in the join condition.
            /// </summary>
            public HashSet<string> ReferencedColumns { get; } = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        }

        /// <summary>
        /// Information about a table referenced in the query.
        /// </summary>
        public sealed class TableInfo
        {
            /// <summary>
            /// Table name.
            /// </summary>
            public string Name { get; set; } = string.Empty;

            /// <summary>
            /// Schema name if specified.
            /// </summary>
            public string? Schema { get; set; }

            /// <summary>
            /// Table alias if specified.
            /// </summary>
            public string? Alias { get; set; }

            /// <summary>
            /// Full table reference text.
            /// </summary>
            public string FullText { get; set; } = string.Empty;
        }

        /// <summary>
        /// Information about an aggregate function.
        /// </summary>
        public sealed class AggregateInfo
        {
            /// <summary>
            /// Type of aggregate (COUNT, SUM, AVG, MIN, MAX, etc.).
            /// </summary>
            public string FunctionName { get; set; } = string.Empty;

            /// <summary>
            /// Column or expression the aggregate operates on.
            /// </summary>
            public string Column { get; set; } = string.Empty;

            /// <summary>
            /// Alias of the aggregate result if specified.
            /// </summary>
            public string? Alias { get; set; }

            /// <summary>
            /// True if the aggregate uses DISTINCT.
            /// </summary>
            public bool IsDistinct { get; set; }

            /// <summary>
            /// Full text of the aggregate expression.
            /// </summary>
            public string FullText { get; set; } = string.Empty;
        }

        #endregion

        #region SQL Structure Visitor

        /// <summary>
        /// Primary visitor that processes the entire SQL structure to populate all properties.
        /// </summary>
        private sealed class SqlStructureVisitor : TSqlFragmentVisitor
        {
            private readonly SqlParser _owner;

            public SqlStructureVisitor(SqlParser owner)
            {
                _owner = owner;
            }

            #region SELECT Statement Processing
            public override void Visit(SelectStatement node)
            {
                _owner.StatementFound = true;

                // If the query expression is a QuerySpecification, 
                // it contains the SELECT columns, WHERE, GROUP BY, etc.
                if (node.QueryExpression is QuerySpecification qs)
                {
                    // Process SELECT columns
                    ProcessSelectElements(qs);

                    // Process TOP clause if present
                    if (qs.TopRowFilter != null)
                    {
                        ProcessTopClause(qs.TopRowFilter);
                    }

                    // Process WHERE clause
                    if (qs.WhereClause != null)
                    {
                        _owner.WhereClauseText = ScriptFragment(qs.WhereClause.SearchCondition);

                        // Collect column references from WHERE
                        var whereColumnVisitor = new ColumnReferenceVisitor();
                        qs.WhereClause.Accept(whereColumnVisitor);
                        foreach (var column in whereColumnVisitor.ColumnReferences)
                        {
                            _owner.WhereColumnReferences.Add(column);
                        }

                        // Build the condition tree
                        var conditionTreeBuilder = new ConditionTreeBuilder();
                        qs.WhereClause.SearchCondition.Accept(conditionTreeBuilder);
                        _owner.WhereConditionTree = new ConditionTree(conditionTreeBuilder.RootNode);
                    }

                    // Process FROM clause and its tables
                    if (qs.FromClause != null)
                    {
                        ProcessFromClause(qs.FromClause);
                    }

                    // Process GROUP BY clause
                    if (qs.GroupByClause != null)
                    {
                        ProcessGroupByClause(qs.GroupByClause);
                    }

                    // Process HAVING clause
                    if (qs.HavingClause != null)
                    {
                        _owner.HasHaving = true;
                        _owner.HavingClauseText = ScriptFragment(qs.HavingClause.SearchCondition);

                        // Collect column references from HAVING
                        var havingColumnVisitor = new ColumnReferenceVisitor();
                        qs.HavingClause.Accept(havingColumnVisitor);
                        foreach (var column in havingColumnVisitor.ColumnReferences)
                        {
                            _owner.HavingColumnReferences.Add(column);
                        }

                        // Build the condition tree for HAVING clause
                        var havingConditionTreeBuilder = new ConditionTreeBuilder();
                        qs.HavingClause.SearchCondition.Accept(havingConditionTreeBuilder);
                        _owner.HavingConditionTree = new ConditionTree(havingConditionTreeBuilder.RootNode);
                    }

                    // Process ORDER BY clause
                    if (qs.OrderByClause != null)
                    {
                        ProcessOrderByClause(qs.OrderByClause);
                    }
                }

                base.Visit(node);
            }

            private void ProcessSelectElements(QuerySpecification qs)
            {
                if (qs.SelectElements == null || qs.SelectElements.Count == 0) return;

                // Check for DISTINCT
                _owner.HasDistinct = qs.UniqueRowFilter == UniqueRowFilter.Distinct;

                foreach (var se in qs.SelectElements)
                {
                    if (se is SelectStarExpression)
                    {
                        // SELECT *
                        _owner.SelectAll = true;
                        _owner.SelectedColumns.Clear();
                        _owner.DetailedColumns.Clear();
                        return;
                    }
                    else if (se is SelectScalarExpression sse)
                    {
                        ProcessSelectScalarExpression(sse);
                    }
                }
            }

            private void ProcessSelectScalarExpression(SelectScalarExpression sse)
            {
                var columnInfo = new ColumnInfo
                {
                    FullText = ScriptFragment(sse),
                    Alias = sse.ColumnName?.Value
                };

                // Process the expression
                if (sse.Expression is ColumnReferenceExpression colRef)
                {
                    // Simple column reference
                    string colName = ExtractColumnNameFromRef(colRef);
                    if (!string.IsNullOrEmpty(colName))
                    {
                        _owner.SelectedColumns.Add(colName);
                        columnInfo.Expression = colName;
                        columnInfo.ReferencedColumns.Add(colName);
                    }
                }
                else if (sse.Expression is FunctionCall funcCall)
                {
                    // Function call (could be an aggregate)
                    ProcessFunctionInSelect(funcCall, columnInfo);
                }
                else if (sse.Expression is ParenthesisExpression parenExpr)
                {
                    // Expression in parentheses
                    columnInfo.IsComputed = true;
                    columnInfo.Expression = ScriptFragment(parenExpr);

                    // Extract column references
                    var colVisitor = new ColumnReferenceVisitor();
                    parenExpr.Accept(colVisitor);
                    foreach (var col in colVisitor.ColumnReferences)
                    {
                        columnInfo.ReferencedColumns.Add(col);
                    }
                }
                else if (sse.Expression is BinaryExpression binExpr)
                {
                    // Binary expression (e.g., a + b)
                    columnInfo.IsComputed = true;
                    columnInfo.Expression = ScriptFragment(binExpr);

                    // Extract column references
                    var colVisitor = new ColumnReferenceVisitor();
                    binExpr.Accept(colVisitor);
                    foreach (var col in colVisitor.ColumnReferences)
                    {
                        columnInfo.ReferencedColumns.Add(col);
                    }
                }
                else if (sse.Expression is CaseExpression caseExpr)
                {
                    // CASE expression
                    columnInfo.IsComputed = true;
                    columnInfo.Expression = ScriptFragment(caseExpr);

                    // Extract column references
                    var colVisitor = new ColumnReferenceVisitor();
                    caseExpr.Accept(colVisitor);
                    foreach (var col in colVisitor.ColumnReferences)
                    {
                        columnInfo.ReferencedColumns.Add(col);
                    }
                }
                else if (sse.Expression is Literal litExpr)
                {
                    // Literal value
                    columnInfo.IsLiteral = true;
                    columnInfo.Expression = ScriptFragment(litExpr);
                }
                else if (sse.Expression is UnaryExpression unaryExpr)
                {
                    // Unary expression (e.g., -a)
                    columnInfo.IsComputed = true;
                    columnInfo.Expression = ScriptFragment(unaryExpr);

                    // Extract column references
                    var colVisitor = new ColumnReferenceVisitor();
                    unaryExpr.Accept(colVisitor);
                    foreach (var col in colVisitor.ColumnReferences)
                    {
                        columnInfo.ReferencedColumns.Add(col);
                    }
                }
                else
                {
                    // Other expressions
                    columnInfo.Expression = ScriptFragment(sse.Expression);
                    columnInfo.IsComputed = true;

                    // Extract column references
                    var colVisitor = new ColumnReferenceVisitor();
                    sse.Expression.Accept(colVisitor);
                    foreach (var col in colVisitor.ColumnReferences)
                    {
                        columnInfo.ReferencedColumns.Add(col);
                    }
                }

                // Add the column info to our list
                _owner.DetailedColumns.Add(columnInfo);

                // Map alias to expression
                if (!string.IsNullOrEmpty(columnInfo.Alias))
                {
                    _owner.ColumnAliases[columnInfo.Alias] = columnInfo.Expression;
                }

                // Add to selected columns if not already added
                if (!string.IsNullOrEmpty(columnInfo.Expression) &&
                    !_owner.SelectedColumns.Contains(columnInfo.Expression) &&
                    !columnInfo.IsComputed && !columnInfo.IsFunction && !columnInfo.IsLiteral)
                {
                    _owner.SelectedColumns.Add(columnInfo.Expression);
                }
            }

            private void ProcessFunctionInSelect(FunctionCall funcCall, ColumnInfo columnInfo)
            {
                string functionName = funcCall.FunctionName.Value ?? string.Empty;
                columnInfo.IsFunction = true;
                columnInfo.FunctionName = functionName;
                columnInfo.Expression = ScriptFragment(funcCall);

                // Check if it's an aggregate function
                bool isAggregate = IsAggregateFunction(functionName);
                columnInfo.IsAggregate = isAggregate;

                if (isAggregate)
                {
                    _owner.HasAggregates = true;

                    // Create aggregate info
                    var aggInfo = new AggregateInfo
                    {
                        FunctionName = functionName,
                        Alias = columnInfo.Alias,
                        FullText = ScriptFragment(funcCall)
                    };

                    // Check for DISTINCT in the aggregate
                    if (string.Equals(funcCall.FunctionName.Value, "COUNT", StringComparison.OrdinalIgnoreCase))
                    {
                        // COUNT might have DISTINCT
                        if (funcCall.Parameters.Count > 0)
                        {
                            // Check if the first parameter is a distinct expression
                            // In SQL Server ScriptDom, DISTINCT isn't directly accessible in the object model
                            // We have to infer it from the SQL text or the parameter properties
                            var param = funcCall.Parameters[0];
                            string paramText = ScriptFragment(param);
                            aggInfo.IsDistinct = paramText.Contains("DISTINCT", StringComparison.OrdinalIgnoreCase);

                            // Extract the column name from the parameter
                            if (param is ColumnReferenceExpression colRef)
                            {
                                aggInfo.Column = ExtractColumnNameFromRef(colRef);
                            }
                            else
                            {
                                aggInfo.Column = paramText;
                            }
                        }
                        else
                        {
                            aggInfo.Column = "*"; // COUNT(*)
                        }
                    }
                    else if (funcCall.Parameters.Count > 0)
                    {
                        // Other aggregates (SUM, AVG, MIN, MAX)
                        var param = funcCall.Parameters[0];
                        string paramText = ScriptFragment(param);

                        // Check for DISTINCT
                        aggInfo.IsDistinct = paramText.Contains("DISTINCT", StringComparison.OrdinalIgnoreCase);

                        // Extract the column reference
                        if (param is ColumnReferenceExpression colRef)
                        {
                            aggInfo.Column = ExtractColumnNameFromRef(colRef);
                        }
                        else
                        {
                            aggInfo.Column = paramText;
                        }
                    }

                    _owner.Aggregates.Add(aggInfo);
                }

                // Extract column references from function parameters
                var colVisitor = new ColumnReferenceVisitor();
                funcCall.Accept(colVisitor);
                foreach (var col in colVisitor.ColumnReferences)
                {
                    columnInfo.ReferencedColumns.Add(col);
                }
            }

            private void ProcessTopClause(TopRowFilter topRowFilter)
            {
                _owner.HasTopClause = true;
                _owner.TopIsPercent = topRowFilter.Percent;

                // Extract TOP value
                if (topRowFilter.Expression is Literal litExpr)
                {
                    _owner.TopValue = litExpr.Value;
                }
                else
                {
                    _owner.TopValue = ScriptFragment(topRowFilter.Expression);
                }
            }

            #endregion

            #region FROM Clause Processing

            private void ProcessFromClause(FromClause fromClause)
            {
                if (fromClause.TableReferences == null || fromClause.TableReferences.Count == 0) return;

                // Process each table reference
                foreach (var tableRef in fromClause.TableReferences)
                {
                    ProcessTableReference(tableRef);
                }
            }

            private void ProcessTableReference(TableReference tableRef)
            {
                if (tableRef is NamedTableReference namedTable)
                {
                    // Simple table reference
                    ProcessNamedTable(namedTable);
                }
                else if (tableRef is QualifiedJoin qualJoin)
                {
                    // JOIN operation
                    ProcessJoin(qualJoin);
                }
                else if (tableRef is JoinParenthesisTableReference parenTable && parenTable.Join != null)
                {
                    // Table reference in parentheses or with alias
                    ProcessTableReference(parenTable.Join);
                }
                else if (tableRef is QueryDerivedTable derivedTable)
                {
                    // Subquery in FROM clause
                    var tableInfo = new TableInfo
                    {
                        Name = "<derived table>",
                        Alias = derivedTable.Alias?.Value,
                        FullText = ScriptFragment(derivedTable)
                    };
                    _owner.Tables.Add(tableInfo);

                    // Process the subquery
                    if (derivedTable.QueryExpression != null)
                    {
                        // We could recursively analyze the subquery if needed
                        // But for now, we just note that it exists
                    }
                }
            }

            private void ProcessNamedTable(NamedTableReference namedTable)
            {
                var tableInfo = new TableInfo
                {
                    FullText = ScriptFragment(namedTable)
                };

                // Extract table name and schema
                if (namedTable.SchemaObject != null && namedTable.SchemaObject.Identifiers.Count > 0)
                {
                    // Last identifier is the table name
                    var identifiers = namedTable.SchemaObject.Identifiers;
                    tableInfo.Name = identifiers[identifiers.Count - 1].Value ?? string.Empty;

                    // If we have multiple identifiers, the second-to-last is the schema
                    if (identifiers.Count > 1)
                    {
                        tableInfo.Schema = identifiers[identifiers.Count - 2].Value;
                    }
                }

                // Extract alias
                tableInfo.Alias = namedTable.Alias?.Value;

                _owner.Tables.Add(tableInfo);
            }

            private void ProcessJoin(QualifiedJoin join)
            {
                _owner.HasJoins = true;

                var joinInfo = new JoinInfo
                {
                    JoinType = join.QualifiedJoinType.ToString(),
                    Condition = join.SearchCondition != null ? ScriptFragment(join.SearchCondition) : string.Empty
                };

                // Process left and right tables
                if (join.FirstTableReference is NamedTableReference leftTable)
                {
                    joinInfo.LeftTable = GetNamedTableIdentifier(leftTable);
                    ProcessNamedTable(leftTable);
                }
                else if (join.FirstTableReference != null)
                {
                    joinInfo.LeftTable = "<complex table>";
                    ProcessTableReference(join.FirstTableReference);
                }

                if (join.SecondTableReference is NamedTableReference rightTable)
                {
                    joinInfo.RightTable = GetNamedTableIdentifier(rightTable);
                    ProcessNamedTable(rightTable);
                }
                else if (join.SecondTableReference != null)
                {
                    joinInfo.RightTable = "<complex table>";
                    ProcessTableReference(join.SecondTableReference);
                }

                // Extract column references from the join condition
                if (join.SearchCondition != null)
                {
                    var colVisitor = new ColumnReferenceVisitor();
                    join.SearchCondition.Accept(colVisitor);
                    foreach (var col in colVisitor.ColumnReferences)
                    {
                        joinInfo.ReferencedColumns.Add(col);
                    }
                }

                _owner.Joins.Add(joinInfo);
            }

            private static string GetNamedTableIdentifier(NamedTableReference namedTable)
            {
                if (namedTable.SchemaObject != null && namedTable.SchemaObject.Identifiers.Count > 0)
                {
                    var identifiers = namedTable.SchemaObject.Identifiers;
                    string tableName = identifiers[identifiers.Count - 1].Value ?? string.Empty;

                    // Include alias if specified
                    if (namedTable.Alias != null && !string.IsNullOrEmpty(namedTable.Alias.Value))
                    {
                        return string.Format(CultureInfo.InvariantCulture, "{0} AS {1}", tableName,
                            namedTable.Alias.Value);
                    }

                    return tableName;
                }

                return string.Empty;
            }

            #endregion

            #region GROUP BY, HAVING, and ORDER BY Processing

            private void ProcessGroupByClause(GroupByClause groupByClause)
            {
                _owner.HasGroupBy = true;

                foreach (var groupByItem in groupByClause.GroupingSpecifications)
                {
                    if (groupByItem is ExpressionGroupingSpecification exprGroup)
                    {
                        if (exprGroup.Expression is ColumnReferenceExpression colRef)
                        {
                            string colName = ExtractColumnNameFromRef(colRef);
                            if (!string.IsNullOrEmpty(colName))
                            {
                                _owner.GroupByColumns.Add(colName);
                            }
                        }
                        else
                        {
                            // For expressions, just add the scripted text
                            _owner.GroupByColumns.Add(ScriptFragment(exprGroup.Expression));
                        }
                    }
                }
            }

            private void ProcessOrderByClause(OrderByClause orderByClause)
            {
                _owner.HasOrderBy = true;

                foreach (var orderByItem in orderByClause.OrderByElements)
                {
                    var orderByInfo = new OrderByInfo
                    {
                        IsDescending = orderByItem.SortOrder == SortOrder.Descending,
                        FullText = ScriptFragment(orderByItem)
                    };

                    if (orderByItem.Expression is ColumnReferenceExpression colRef)
                    {
                        orderByInfo.ColumnName = ExtractColumnNameFromRef(colRef);
                    }
                    else
                    {
                        // For expressions, use the full text
                        orderByInfo.ColumnName = ScriptFragment(orderByItem.Expression);
                    }

                    _owner.OrderByColumns.Add(orderByInfo);
                }
            }

            #endregion

            #region Helper Methods

            private static string ExtractColumnNameFromRef(ColumnReferenceExpression colRef)
            {
                if (colRef.MultiPartIdentifier != null && colRef.MultiPartIdentifier.Identifiers.Count > 0)
                {
                    // For qualified names (t.column), get just the column part (last identifier)
                    var identifiers = colRef.MultiPartIdentifier.Identifiers;
                    return identifiers[identifiers.Count - 1].Value ?? string.Empty;
                }

                return string.Empty;
            }

            private static bool IsAggregateFunction(string functionName)
            {
                if (string.IsNullOrEmpty(functionName)) return false;

                var aggregateFunctions = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
                {
                    "COUNT", "SUM", "AVG", "MIN", "MAX", "STDEV", "STDEVP", "VAR", "VARP",
                    "CHECKSUM_AGG", "COUNT_BIG", "GROUPING", "GROUPING_ID", "STRING_AGG"
                };

                return aggregateFunctions.Contains(functionName);
            }

            #endregion
        }

        #endregion

        #region Column Reference Visitor

        /// <summary>
        /// Visitor that collects column references from expressions.
        /// </summary>
        private sealed class ColumnReferenceVisitor : TSqlFragmentVisitor
        {
            /// <summary>
            /// List of column names found.
            /// </summary>
            public HashSet<string> ColumnReferences { get; } = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

            public override void Visit(ColumnReferenceExpression node)
            {
                if (node.MultiPartIdentifier != null && node.MultiPartIdentifier.Identifiers.Count > 0)
                {
                    // The last identifier is the column name
                    var identifiers = node.MultiPartIdentifier.Identifiers;
                    string columnName = identifiers[identifiers.Count - 1].Value ?? string.Empty;

                    if (!string.IsNullOrEmpty(columnName))
                    {
                        ColumnReferences.Add(columnName);
                    }
                }

                base.Visit(node);
            }
        }

        #endregion

        #region Helper Methods

        /// <summary>
        /// Renders (scripts) a TSqlFragment back to a string, 
        /// preserving T-SQL formatting as best as possible.
        /// </summary>
        private static string ScriptFragment(TSqlFragment fragment)
        {
            if (fragment == null) return string.Empty;

            var generator = new Sql150ScriptGenerator(new SqlScriptGeneratorOptions
            {
                KeywordCasing = KeywordCasing.Uppercase
            });

            generator.GenerateScript(fragment, out string script);
            return script.Trim();
        }

        /// <summary>
        /// Checks if the string is a common SQL keyword.
        /// </summary>
        private static bool IsSqlKeyword(string word)
        {
            if (string.IsNullOrEmpty(word)) return false;

            // Common SQL keywords that might appear in expressions
            HashSet<string> keywords = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
            {
                "SELECT", "FROM", "WHERE", "AND", "OR", "NOT", "IN", "BETWEEN", "LIKE",
                "IS", "NULL", "TRUE", "FALSE", "AS", "ON", "JOIN", "INNER", "OUTER",
                "LEFT", "RIGHT", "FULL", "CROSS", "GROUP", "BY", "HAVING", "ORDER",
                "DESC", "ASC", "LIMIT", "OFFSET", "UNION", "ALL", "DISTINCT", "TOP"
            };

            return keywords.Contains(word);
        }

        /// <summary>
        /// Returns a simple string representation of the query structure for debugging.
        /// </summary>
        public string GetQuerySummary()
        {
            var sb = new StringBuilder();

            sb.AppendLine("QUERY SUMMARY:");
            sb.AppendLine(string.Format(CultureInfo.InvariantCulture, "Statement Found: {0}", StatementFound));
            sb.AppendLine(string.Format(CultureInfo.InvariantCulture, "Select All (*): {0}", SelectAll));

            if (SelectedColumns.Count > 0)
            {
                sb.AppendLine("Selected Columns:");
                foreach (var col in SelectedColumns)
                {
                    sb.AppendLine(string.Format(CultureInfo.InvariantCulture, "  - {0}", col));
                }
            }

            if (DetailedColumns.Count > 0)
            {
                sb.AppendLine("Detailed Columns:");
                foreach (var col in DetailedColumns)
                {
                    sb.AppendLine(string.Format(CultureInfo.InvariantCulture,
                        "  - {0}{1}{2}{3}",
                        col.Expression,
                        col.Alias != null ? string.Format(CultureInfo.InvariantCulture, " AS {0}", col.Alias) : "",
                        col.IsFunction
                            ? string.Format(CultureInfo.InvariantCulture, " (Function: {0})", col.FunctionName)
                            : "",
                        col.IsAggregate ? " (Aggregate)" : ""));
                }
            }

            if (!string.IsNullOrEmpty(WhereClauseText))
            {
                sb.AppendLine(string.Format(CultureInfo.InvariantCulture, "Where Clause: {0}", WhereClauseText));
                sb.AppendLine("Where Column References:");
                foreach (var col in WhereColumnReferences)
                {
                    sb.AppendLine(string.Format(CultureInfo.InvariantCulture, "  - {0}", col));
                }
            }

            if (HasGroupBy)
            {
                sb.AppendLine("Group By Columns:");
                foreach (var col in GroupByColumns)
                {
                    sb.AppendLine(string.Format(CultureInfo.InvariantCulture, "  - {0}", col));
                }
            }

            if (HasHaving)
            {
                sb.AppendLine(string.Format(CultureInfo.InvariantCulture, "Having Clause: {0}", HavingClauseText));
                sb.AppendLine("Having Column References:");
                foreach (var col in HavingColumnReferences)
                {
                    sb.AppendLine(string.Format(CultureInfo.InvariantCulture, "  - {0}", col));
                }
            }

            if (HasOrderBy)
            {
                sb.AppendLine("Order By Columns:");
                foreach (var col in OrderByColumns)
                {
                    sb.AppendLine(string.Format(CultureInfo.InvariantCulture,
                        "  - {0} {1}", col.ColumnName, col.IsDescending ? "DESC" : "ASC"));
                }
            }

            if (Tables.Count > 0)
            {
                sb.AppendLine("Tables:");
                foreach (var table in Tables)
                {
                    sb.AppendLine(string.Format(CultureInfo.InvariantCulture,
                        "  - {0}{1}{2}",
                        table.Name,
                        table.Schema != null
                            ? string.Format(CultureInfo.InvariantCulture, " (Schema: {0})", table.Schema)
                            : "",
                        table.Alias != null
                            ? string.Format(CultureInfo.InvariantCulture, " AS {0}", table.Alias)
                            : ""));
                }
            }

            if (HasJoins)
            {
                sb.AppendLine("Joins:");
                foreach (var join in Joins)
                {
                    sb.AppendLine(string.Format(CultureInfo.InvariantCulture,
                        "  - {0} JOIN {1} ON {2}", join.JoinType, join.RightTable, join.Condition));
                }
            }

            if (HasAggregates)
            {
                sb.AppendLine("Aggregates:");
                foreach (var agg in Aggregates)
                {
                    sb.AppendLine(string.Format(CultureInfo.InvariantCulture,
                        "  - {0}({1}{2}){3}",
                        agg.FunctionName,
                        agg.IsDistinct ? "DISTINCT " : "",
                        agg.Column,
                        agg.Alias != null ? string.Format(CultureInfo.InvariantCulture, " AS {0}", agg.Alias) : ""));
                }
            }

            return sb.ToString();
        }
        #endregion

        #region Condition Tree Implementation

        /// <summary>
        /// Base class for all condition nodes in the SQL condition tree.
        /// </summary>
        public abstract class ConditionNode
        {
            /// <summary>
            /// Evaluates this condition against the specified row data.
            /// </summary>
            public abstract bool Evaluate(IDictionary<string, object> rowData);
        }

        /// <summary>
        /// Represents a logical operator (AND, OR, NOT) in the condition tree.
        /// </summary>
        public sealed class LogicalOperatorNode : ConditionNode
        {
            /// <summary>
            /// Type of logical operator.
            /// </summary>
            public enum LogicalOperatorType
            {
                And,
                Or,
                Not
            }

            /// <summary>
            /// The operator type.
            /// </summary>
            public LogicalOperatorType OperatorType { get; }

            /// <summary>
            /// Left operand (maybe null for NOT).
            /// </summary>
            public ConditionNode? Left { get; }

            /// <summary>
            /// Right operand (maybe null for NOT).
            /// </summary>
            public ConditionNode? Right { get; }

            public LogicalOperatorNode(LogicalOperatorType operatorType, ConditionNode? left, ConditionNode? right)
            {
                OperatorType = operatorType;
                Left = left;
                Right = right;
            }

            public override bool Evaluate(IDictionary<string, object> rowData)
            {
                return OperatorType switch
                {
                    LogicalOperatorType.And => Left!.Evaluate(rowData) && Right!.Evaluate(rowData),
                    LogicalOperatorType.Or => Left!.Evaluate(rowData) || Right!.Evaluate(rowData),
                    LogicalOperatorType.Not => !Right!.Evaluate(rowData),
                    _ => throw new NotSupportedException($"Logical operator {OperatorType} not supported.")
                };
            }
        }

        /// <summary>
        /// Represents a comparison operation in the condition tree.
        /// </summary>
        public sealed class ComparisonNode : ConditionNode
        {
            /// <summary>
            /// Type of comparison operation.
            /// </summary>
            public enum ComparisonType
            {
                Equals,
                NotEquals,
                LessThan,
                LessThanOrEqual,
                GreaterThan,
                GreaterThanOrEqual,
                Like,
                In,
                Between,
                IsNull,
                IsNotNull
            }

            /// <summary>
            /// The comparison type.
            /// </summary>
            public ComparisonType Comparison { get; }

            /// <summary>
            /// Left operand of the comparison (usually a column).
            /// </summary>
            public ExpressionNode Left { get; }

            /// <summary>
            /// Right operand of the comparison (usually a value).
            /// </summary>
            public ExpressionNode? Right { get; }

            /// <summary>
            /// Second right operand (for BETWEEN).
            /// </summary>
            public ExpressionNode? Right2 { get; }

            /// <summary>
            /// List of values for IN comparison.
            /// </summary>
            public List<ExpressionNode>? InValues { get; }

            public ComparisonNode(ComparisonType comparison, ExpressionNode left, ExpressionNode? right = null,
                                    ExpressionNode? right2 = null, List<ExpressionNode>? inValues = null)
            {
                Comparison = comparison;
                Left = left;
                Right = right;
                Right2 = right2;
                InValues = inValues;
            }

            public override bool Evaluate(IDictionary<string, object> rowData)
            {
                object? leftValue = Left.GetValue(rowData);

                switch (Comparison)
                {
                    case ComparisonType.IsNull:
                        return leftValue == null || leftValue == DBNull.Value;

                    case ComparisonType.IsNotNull:
                        return leftValue != null && leftValue != DBNull.Value;

                    case ComparisonType.In:
                        if (leftValue == null) return false;
                        return InValues!.Any(v => CompareValues(leftValue, v.GetValue(rowData), ComparisonType.Equals));

                    case ComparisonType.Between:
                        if (leftValue == null) return false;
                        object? lower = Right!.GetValue(rowData);
                        object? upper = Right2!.GetValue(rowData);
                        return CompareValues(leftValue, lower, ComparisonType.GreaterThanOrEqual) &&
                                CompareValues(leftValue, upper, ComparisonType.LessThanOrEqual);

                    default:
                        if (Right == null) throw new InvalidOperationException($"Right operand missing for {Comparison} comparison");
                        object? rightValue = Right.GetValue(rowData);
                        return CompareValues(leftValue, rightValue, Comparison);
                }
            }

            private static bool CompareValues(object? left, object? right, ComparisonType comparisonType)
            {
                // Handle null values
                if (left == null || left == DBNull.Value || right == null || right == DBNull.Value)
                {
                    // Special handling for NULL comparisons
                    // In SQL, NULL compared to anything (including another NULL) is UNKNOWN, not TRUE or FALSE
                    // The only exceptions are IS NULL and IS NOT NULL
                    return false;
                }

                // Try to convert types for comparison
                if (left.GetType() != right.GetType())
                {
                    try
                    {
                        if (left is IConvertible convertibleLeft && right is IConvertible convertibleRight)
                        {
                            // Convert right to match left's type if possible
                            Type leftType = left.GetType();
                            right = Convert.ChangeType(right, leftType, CultureInfo.InvariantCulture);
                        }
                    }
                    catch (InvalidCastException)
                    {
                        // Failed type conversion, can't compare
                        return false;
                    }
                    catch (FormatException)
                    {
                        // Failed type conversion, can't compare
                        return false;
                    }
                }

                // If the objects are comparable
                if (left is IComparable comparable)
                {
                    int result = comparable.CompareTo(right);

                    return comparisonType switch
                    {
                        ComparisonType.Equals => result == 0,
                        ComparisonType.NotEquals => result != 0,
                        ComparisonType.LessThan => result < 0,
                        ComparisonType.LessThanOrEqual => result <= 0,
                        ComparisonType.GreaterThan => result > 0,
                        ComparisonType.GreaterThanOrEqual => result >= 0,
                        ComparisonType.Like when left is string leftStr && right is string rightStr =>
                            SqlLikeOperator.Like(leftStr, rightStr),
                        _ => false
                    };
                }

                // For non-comparable objects, we can only check equality
                return comparisonType == ComparisonType.Equals ? left.Equals(right) : false;
            }
        }

        /// <summary>
        /// Base class for expression nodes.
        /// </summary>
        public abstract class ExpressionNode
        {
            /// <summary>
            /// Gets the value of this expression from the row data.
            /// </summary>
            public abstract object? GetValue(IDictionary<string, object> rowData);
        }

        /// <summary>
        /// Represents a column reference in an expression.
        /// </summary>
        public sealed class ColumnReferenceNode : ExpressionNode
        {
            /// <summary>
            /// The name of the column.
            /// </summary>
            public string ColumnName { get; }

            public ColumnReferenceNode(string columnName)
            {
                ColumnName = columnName;
            }

            public override object? GetValue(IDictionary<string, object> rowData)
            {
                return rowData.TryGetValue(ColumnName, out object? value) ? value : null;
            }
        }

        /// <summary>
        /// Represents a literal value in an expression.
        /// </summary>
        public sealed class LiteralNode : ExpressionNode
        {
            /// <summary>
            /// The literal value.
            /// </summary>
            public object? Value { get; }

            /// <summary>
            /// The SQL type of the literal.
            /// </summary>
            public SqlDataType DataType { get; }

            public LiteralNode(object? value, SqlDataType dataType)
            {
                Value = value;
                DataType = dataType;
            }

            public override object? GetValue(IDictionary<string, object> rowData)
            {
                return Value;
            }
        }

        /// <summary>
        /// Represents a parameter (@Name) in an expression.
        /// </summary>
        public sealed class ParameterNode : ExpressionNode
        {
            /// <summary>
            /// The name of the parameter (including @).
            /// </summary>
            public string ParameterName { get; }

            public ParameterNode(string parameterName)
            {
                ParameterName = parameterName;
            }

            public override object? GetValue(IDictionary<string, object> rowData)
            {
                string key = ParameterName.TrimStart('@');
                return rowData.TryGetValue(key, out object? value) ? value : null;
            }
        }

        /// <summary>
        /// Represents a function call in an expression.
        /// </summary>
        public sealed class FunctionNode : ExpressionNode
        {
            /// <summary>
            /// The name of the function.
            /// </summary>
            public string FunctionName { get; }

            /// <summary>
            /// The arguments to the function.
            /// </summary>
            public List<ExpressionNode> Arguments { get; }

            public FunctionNode(string functionName, List<ExpressionNode> arguments)
            {
                FunctionName = functionName;
                Arguments = arguments;
            }

            [SuppressMessage("Globalization", "CA1308:Normalize strings to uppercase", Justification = "Implementing SQL LOWER() function which requires lowercase")]
            public override object? GetValue(IDictionary<string, object> rowData)
            {
                // Get argument values
                object?[] args = Arguments.Select(arg => arg.GetValue(rowData)).ToArray();

                // Execute the function based on its name
                return FunctionName.ToUpperInvariant() switch
                {
                    "YEAR" when args.Length == 1 && args[0] is DateTime date => date.Year,
                    "MONTH" when args.Length == 1 && args[0] is DateTime date => date.Month,
                    "DAY" when args.Length == 1 && args[0] is DateTime date => date.Day,
                    "GETDATE" when args.Length == 0 => DateTime.Now,
                    "DATEADD" when args.Length == 3 && args[1] is int value =>
                        AddToDate(args[0]?.ToString(), value, args[2] as DateTime?),
                    "UPPER" when args.Length == 1 && args[0] is string str => str.ToUpperInvariant(),
                    "LOWER" when args.Length == 1 && args[0] is string str => str.ToLowerInvariant(),
                    _ => throw new NotSupportedException($"Function {FunctionName} not supported or invalid arguments.")
                };
            }

            private static DateTime? AddToDate(string? part, int value, DateTime? date)
            {
                if (date == null || part == null) return null;

                return part.ToUpperInvariant() switch
                {
                    "YEAR" or "YY" or "YYYY" => date.Value.AddYears(value),
                    "MONTH" or "MM" or "M" => date.Value.AddMonths(value),
                    "DAY" or "DD" or "D" => date.Value.AddDays(value),
                    "HOUR" or "HH" => date.Value.AddHours(value),
                    "MINUTE" or "MI" or "N" => date.Value.AddMinutes(value),
                    "SECOND" or "SS" or "S" => date.Value.AddSeconds(value),
                    _ => throw new ArgumentException($"Invalid date part: {part}")
                };
            }
        }

        /// <summary>
        /// Represents a SQL data type.
        /// </summary>
        public enum SqlDataType
        {
            Unknown,
            String,
            Int,
            Decimal,
            DateTime,
            Boolean,
            Null
        }

        /// <summary>
        /// Utility for SQL LIKE operator.
        /// </summary>
        public static class SqlLikeOperator
        {
            /// <summary>
            /// Implements the SQL LIKE operator.
            /// </summary>
            public static bool Like(string input, string pattern)
            {
                // Convert SQL LIKE pattern to regex
                string regexPattern = "^" + Regex.Escape(pattern)
                    .Replace("%", ".*", StringComparison.Ordinal)
                    .Replace("_", ".", StringComparison.Ordinal)
                    .Replace(@"\[", "[", StringComparison.Ordinal)
                    .Replace(@"\]", "]", StringComparison.Ordinal)
                    .Replace(@"\^", "^", StringComparison.Ordinal) + "$";

                return Regex.IsMatch(input, regexPattern, RegexOptions.IgnoreCase | RegexOptions.CultureInvariant);
            }
        }

        /// <summary>
        /// The root of a condition tree, representing a complete WHERE or HAVING clause.
        /// </summary>
        public sealed class ConditionTree
        {
            /// <summary>
            /// The root node of the condition tree.
            /// </summary>
            public ConditionNode? Root { get; }

            public ConditionTree(ConditionNode? root)
            {
                Root = root;
            }

            /// <summary>
            /// Evaluates the condition tree against the specified row data.
            /// </summary>
            public bool Evaluate(IDictionary<string, object> rowData)
            {
                return Root == null || Root.Evaluate(rowData);
            }
        }

        #endregion

        #region Condition Tree Builder
        /// <summary>
        /// Builds a condition tree from SQL search conditions.
        /// </summary>
        private sealed class ConditionTreeBuilder : TSqlFragmentVisitor
        {
            private ConditionNode? _currentNode;
            private readonly Dictionary<string, ExpressionNode> _parameters = new Dictionary<string, ExpressionNode>(StringComparer.OrdinalIgnoreCase);

            public ConditionNode? RootNode => _currentNode;


            public override void Visit(BooleanBinaryExpression node)
            {
                // Process the left sub-expression
                node.FirstExpression.Accept(this);
                ConditionNode? leftNode = _currentNode;

                // Process the right sub-expression
                node.SecondExpression.Accept(this);
                ConditionNode? rightNode = _currentNode;

                if (leftNode != null && rightNode != null)
                {
                    var opType = node.BinaryExpressionType switch
                    {
                        BooleanBinaryExpressionType.And => LogicalOperatorNode.LogicalOperatorType.And,
                        BooleanBinaryExpressionType.Or => LogicalOperatorNode.LogicalOperatorType.Or,
                        _ => throw new NotSupportedException($"Unsupported boolean operator: {node.BinaryExpressionType}")
                    };

                    _currentNode = new LogicalOperatorNode(opType, leftNode, rightNode);
                }
            }

            private void ProcessComparisonExpression(BooleanComparisonExpression compExpr)
            {
                // Extract left and right expressions
                ExpressionNode? leftExpr = ProcessScalarExpression(compExpr.FirstExpression);
                ExpressionNode? rightExpr = ProcessScalarExpression(compExpr.SecondExpression);

                if (leftExpr == null || rightExpr == null) return;

                // Determine comparison type
                ComparisonNode.ComparisonType comparisonType;

                // Use string comparison since property names might differ across versions
                string compTypeStr = compExpr.ComparisonType.ToString();

                comparisonType = compTypeStr switch
                {
                    var s when s.Contains("Equals", StringComparison.Ordinal) => ComparisonNode.ComparisonType.Equals,
                    var s when s.Contains("NotEqual", StringComparison.Ordinal) || s.Contains("NotEquals", StringComparison.Ordinal) => ComparisonNode.ComparisonType.NotEquals,
                    var s when s.Contains("GreaterThan", StringComparison.Ordinal) && s.Contains("Equal", StringComparison.Ordinal) => ComparisonNode.ComparisonType.GreaterThanOrEqual,
                    var s when s.Contains("LessThan", StringComparison.Ordinal) && s.Contains("Equal", StringComparison.Ordinal) => ComparisonNode.ComparisonType.LessThanOrEqual,
                    var s when s.Contains("GreaterThan", StringComparison.Ordinal) => ComparisonNode.ComparisonType.GreaterThan,
                    var s when s.Contains("LessThan", StringComparison.Ordinal) => ComparisonNode.ComparisonType.LessThan,
                    _ => ComparisonNode.ComparisonType.Equals // Default
                };

                _currentNode = new ComparisonNode(comparisonType, leftExpr, rightExpr);
            }

            private void ProcessIsNullExpression(BooleanIsNullExpression isNullExpr)
            {
                ExpressionNode? expr = ProcessScalarExpression(isNullExpr.Expression);
                if (expr == null) return;

                ComparisonNode.ComparisonType comparisonType = isNullExpr.IsNot
                    ? ComparisonNode.ComparisonType.IsNotNull
                    : ComparisonNode.ComparisonType.IsNull;

                _currentNode = new ComparisonNode(comparisonType, expr);
            }

            private void ProcessInPredicate(InPredicate inPredicate)
            {
                ExpressionNode? expr = ProcessScalarExpression(inPredicate.Expression);
                if (expr == null) return;

                var inValues = new List<ExpressionNode>();
                if (inPredicate.Values != null)
                {
                    foreach (var value in inPredicate.Values)
                    {
                        ExpressionNode? valueExpr = ProcessScalarExpression(value);
                        if (valueExpr != null)
                        {
                            inValues.Add(valueExpr);
                        }
                    }
                }

                ComparisonNode.ComparisonType comparisonType = inPredicate.NotDefined
                    ? ComparisonNode.ComparisonType.NotEquals   // NOT IN is handled as multiple NOT EQUALS
                    : ComparisonNode.ComparisonType.In;

                _currentNode = new ComparisonNode(comparisonType, expr, null, null, inValues);
            }

            // Corrected to handle BetweenPredicate
            private void ProcessBetweenPredicate(ScalarExpression expression, ScalarExpression lowerBound, ScalarExpression upperBound)
            {
                ExpressionNode? expr = ProcessScalarExpression(expression);
                ExpressionNode? lower = ProcessScalarExpression(lowerBound);
                ExpressionNode? upper = ProcessScalarExpression(upperBound);

                if (expr == null || lower == null || upper == null) return;

                // Instead of creating ScriptDom objects, create our own ConditionNode objects directly
                _currentNode = new ComparisonNode(
                    ComparisonNode.ComparisonType.Between,
                    expr,
                    lower,
                    upper
                );
            }

            private void ProcessLikePredicate(LikePredicate likePredicate)
            {
                ExpressionNode? expr = ProcessScalarExpression(likePredicate.FirstExpression);
                ExpressionNode? patternExpr = ProcessScalarExpression(likePredicate.SecondExpression);

                if (expr == null || patternExpr == null) return;

                ComparisonNode.ComparisonType comparisonType = likePredicate.NotDefined
                    ? ComparisonNode.ComparisonType.NotEquals   // NOT LIKE is handled as NOT EQUALS
                    : ComparisonNode.ComparisonType.Like;

                _currentNode = new ComparisonNode(comparisonType, expr, patternExpr);
            }

            private ExpressionNode? ProcessScalarExpression(ScalarExpression? expression)
            {
                if (expression == null) return null;

                if (expression is ColumnReferenceExpression colRef)
                {
                    // Handle column references
                    if (colRef.MultiPartIdentifier != null && colRef.MultiPartIdentifier.Identifiers.Count > 0)
                    {
                        var identifiers = colRef.MultiPartIdentifier.Identifiers;
                        string columnName = identifiers[identifiers.Count - 1].Value ?? string.Empty;

                        return new ColumnReferenceNode(columnName);
                    }
                }
                else if (expression is Literal literal)
                {
                    // Handle literals
                    return ProcessLiteral(literal);
                }
                else if (expression is VariableReference varRef)
                {
                    // Handle parameters (@Name)
                    string paramName = varRef.Name;
                    if (_parameters.TryGetValue(paramName, out ExpressionNode? paramNode))
                    {
                        return paramNode;
                    }

                    paramNode = new ParameterNode(paramName);
                    _parameters[paramName] = paramNode;
                    return paramNode;
                }
                else if (expression is FunctionCall funcCall)
                {
                    // Handle function calls
                    return ProcessFunction(funcCall);
                }
                else if (expression is UnaryExpression unaryExpr)
                {
                    // Handle unary expressions (e.g., -a)
                    var innerExpr = ProcessScalarExpression(unaryExpr.Expression);

                    if (innerExpr is LiteralNode litNode && unaryExpr.UnaryExpressionType == UnaryExpressionType.Negative)
                    {
                        // For numeric literals, negate the value
                        if (litNode.Value is int intVal)
                        {
                            return new LiteralNode(-intVal, SqlDataType.Int);
                        }
                        else if (litNode.Value is decimal decVal)
                        {
                            return new LiteralNode(-decVal, SqlDataType.Decimal);
                        }
                        else if (litNode.Value is double dblVal)
                        {
                            return new LiteralNode(-dblVal, SqlDataType.Decimal);
                        }
                    }

                    return innerExpr; // For now, just return the inner expression
                }
                else if (expression is ParenthesisExpression parenExpr)
                {
                    // Handle expressions in parentheses
                    return ProcessScalarExpression(parenExpr.Expression);
                }

                return null;
            }

            private static LiteralNode ProcessLiteral(Literal literal)
            {
                SqlDataType dataType = SqlDataType.Unknown;
                object? value = null;

                if (literal is NullLiteral)
                {
                    dataType = SqlDataType.Null;
                    value = null;
                }
                else if (literal is StringLiteral strLiteral)
                {
                    dataType = SqlDataType.String;
                    value = strLiteral.Value;
                }
                else if (literal is IntegerLiteral intLiteral)
                {
                    dataType = SqlDataType.Int;
                    if (int.TryParse(intLiteral.Value, System.Globalization.CultureInfo.InvariantCulture, out int intValue))
                    {
                        value = intValue;
                    }
                }
                else if (literal is NumericLiteral numLiteral)
                {
                    dataType = SqlDataType.Decimal;
                    if (decimal.TryParse(numLiteral.Value, System.Globalization.CultureInfo.InvariantCulture, out decimal decValue))
                    {
                        value = decValue;
                    }
                }
                else if (literal is BinaryLiteral binLiteral)
                {
                    // Handle binary literals (0x...)
                    dataType = SqlDataType.String; // Default to string for now
                    value = binLiteral.Value;
                }
                else if (literal is MoneyLiteral moneyLiteral)
                {
                    dataType = SqlDataType.Decimal;
                    string moneyStr = moneyLiteral.Value;
                    if (moneyStr.StartsWith('$'))
                    {
                        moneyStr = moneyStr[1..];
                    }

                    if (decimal.TryParse(moneyStr, System.Globalization.CultureInfo.InvariantCulture, out decimal decValue))
                    {
                        value = decValue;
                    }
                }
                else if (literal is DefaultLiteral)
                {
                    // DEFAULT keyword - for now, just return null
                    dataType = SqlDataType.Null;
                    value = null;
                }

                return new LiteralNode(value, dataType);
            }

            // Make this non-static since it needs to call ProcessScalarExpression
            private FunctionNode? ProcessFunction(FunctionCall funcCall)
            {
                string functionName = funcCall.FunctionName.Value ?? string.Empty;
                var arguments = new List<ExpressionNode>();

                foreach (var param in funcCall.Parameters)
                {
                    ExpressionNode? paramNode = ProcessScalarExpression(param);
                    if (paramNode != null)
                    {
                        arguments.Add(paramNode);
                    }
                }

                return new FunctionNode(functionName, arguments);
            }
        }

        #endregion
    }
}
```

## VirtualColumn.cs
*Source: B:\Github\Parquet.Data.Ado\Parquet.Data.Ado\VirtualColumn.cs*

```
using System;
using System.ComponentModel.DataAnnotations;

namespace Parquet.Data.Reader
{
    /// <summary>
    /// Represents a data column in a Parquet data reader, including virtual columns that don't exist in the physical file.
    /// </summary>
    public class VirtualColumn
    {
        /// <summary>
        /// Gets or sets the name of the column.
        /// </summary>
        public string ColumnName { get; set; }

        /// <summary>
        /// Gets or sets the CLR data type of the column.
        /// </summary>
        /// <remarks>
        /// This property represents the data type of the column, which may differ from the physical column type
        /// in cases where the column is virtual or has been transformed.
        /// </remarks>
        public Type DataType { get; set; }

        /// <summary>
        /// Gets or sets the default value for the column.
        /// </summary>
        public object DefaultValue { get; set; }

        /// <summary>
        /// Gets or sets whether the column is a virtual column (not physically present in the Parquet file).
        /// </summary>
        public bool IsVirtual { get; set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="VirtualColumn"/> class.
        /// </summary>
        /// <param name="columnName">The name of the column.</param>
        /// <param name="columnType">The CLR data type of the column.</param>
        /// <param name="defaultValue">The default value for the column.</param>
        /// <param name="isVirtual">Whether the column is a virtual column.</param>
        public VirtualColumn(string columnName, Type columnType, object? defaultValue = null, bool isVirtual = true)
        {
            ColumnName = columnName ?? throw new ArgumentNullException(nameof(columnName));
            DataType = columnType ?? throw new ArgumentNullException(nameof(columnType));
            DefaultValue = defaultValue ?? DBNull.Value;
            IsVirtual = isVirtual;
        }
    }
}
```

